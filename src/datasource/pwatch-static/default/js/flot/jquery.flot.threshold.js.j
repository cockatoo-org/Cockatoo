{"etag":"\"8c5df27b-8f30-169b-dcb5e0972afa7852\"","type":"text\/javascript","exp":"86400","desc":null,"data":"\/*\nFlot plugin for thresholding data. Controlled through the option\n\"threshold\" in either the global series options\n\n  series: {\n    threshold: {\n      below: number\n      color: colorspec\n    }\n  }\n\nor in a specific series\n\n  $.plot($(\"#placeholder\"), [{ data: [ ... ], threshold: { ... }}])\n\nThe data points below \"below\" are drawn with the specified color. This\nmakes it easy to mark points below 0, e.g. for budget data.\n\nInternally, the plugin works by splitting the data into two series,\nabove and below the threshold. The extra series below the threshold\nwill have its label cleared and the special \"originSeries\" attribute\nset to the original series. You may need to check for this in hover\nevents.\n*\/\n\n(function ($) {\n    var options = {\n        series: { threshold: null } \/\/ or { below: number, color: color spec}\n    };\n    \n    function init(plot) {\n        function thresholdData(plot, s, datapoints) {\n            if (!s.threshold)\n                return;\n            \n            var ps = datapoints.pointsize, i, x, y, p, prevp,\n                thresholded = $.extend({}, s); \/\/ note: shallow copy\n\n            thresholded.datapoints = { points: [], pointsize: ps };\n            thresholded.label = null;\n            thresholded.color = s.threshold.color;\n            thresholded.threshold = null;\n            thresholded.originSeries = s;\n            thresholded.data = [];\n\n            var below = s.threshold.below,\n                origpoints = datapoints.points,\n                addCrossingPoints = s.lines.show;\n\n            threspoints = [];\n            newpoints = [];\n\n            for (i = 0; i < origpoints.length; i += ps) {\n                x = origpoints[i]\n                y = origpoints[i + 1];\n\n                prevp = p;\n                if (y < below)\n                    p = threspoints;\n                else\n                    p = newpoints;\n\n                if (addCrossingPoints && prevp != p && x != null\n                    && i > 0 && origpoints[i - ps] != null) {\n                    var interx = (x - origpoints[i - ps]) \/ (y - origpoints[i - ps + 1]) * (below - y) + x;\n                    prevp.push(interx);\n                    prevp.push(below);\n                    for (m = 2; m < ps; ++m)\n                        prevp.push(origpoints[i + m]);\n                    \n                    p.push(null); \/\/ start new segment\n                    p.push(null);\n                    for (m = 2; m < ps; ++m)\n                        p.push(origpoints[i + m]);\n                    p.push(interx);\n                    p.push(below);\n                    for (m = 2; m < ps; ++m)\n                        p.push(origpoints[i + m]);\n                }\n\n                p.push(x);\n                p.push(y);\n            }\n\n            datapoints.points = newpoints;\n            thresholded.datapoints.points = threspoints;\n            \n            if (thresholded.datapoints.points.length > 0)\n                plot.getData().push(thresholded);\n                \n            \/\/ FIXME: there are probably some edge cases left in bars\n        }\n        \n        plot.hooks.processDatapoints.push(thresholdData);\n    }\n    \n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'threshold',\n        version: '1.0'\n    });\n})(jQuery);\n","_u":"js\/flot\/jquery.flot.threshold.js"}