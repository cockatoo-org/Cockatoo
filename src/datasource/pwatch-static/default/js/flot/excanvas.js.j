{"etag":"\"5c015eb4-5975-966e-2330bb564500e81a\"","type":"text\/javascript","exp":"86400","desc":null,"data":"\/\/ Copyright 2006 Google Inc.\n\/\/\n\/\/ Licensed under the Apache License, Version 2.0 (the \"License\");\n\/\/ you may not use this file except in compliance with the License.\n\/\/ You may obtain a copy of the License at\n\/\/\n\/\/   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\/\/\n\/\/ Unless required by applicable law or agreed to in writing, software\n\/\/ distributed under the License is distributed on an \"AS IS\" BASIS,\n\/\/ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\/\/ See the License for the specific language governing permissions and\n\/\/ limitations under the License.\n\n\n\/\/ Known Issues:\n\/\/\n\/\/ * Patterns only support repeat.\n\/\/ * Radial gradient are not implemented. The VML version of these look very\n\/\/   different from the canvas one.\n\/\/ * Clipping paths are not implemented.\n\/\/ * Coordsize. The width and height attribute have higher priority than the\n\/\/   width and height style values which isn't correct.\n\/\/ * Painting mode isn't implemented.\n\/\/ * Canvas width\/height should is using content-box by default. IE in\n\/\/   Quirks mode will draw the canvas using border-box. Either change your\n\/\/   doctype to HTML5\n\/\/   (http:\/\/www.whatwg.org\/specs\/web-apps\/current-work\/#the-doctype)\n\/\/   or use Box Sizing Behavior from WebFX\n\/\/   (http:\/\/webfx.eae.net\/dhtml\/boxsizing\/boxsizing.html)\n\/\/ * Non uniform scaling does not correctly scale strokes.\n\/\/ * Filling very large shapes (above 5000 points) is buggy.\n\/\/ * Optimize. There is always room for speed improvements.\n\n\/\/ Only add this code if we do not already have a canvas implementation\nif (!document.createElement('canvas').getContext) {\n\n(function() {\n\n  \/\/ alias some functions to make (compiled) code shorter\n  var m = Math;\n  var mr = m.round;\n  var ms = m.sin;\n  var mc = m.cos;\n  var abs = m.abs;\n  var sqrt = m.sqrt;\n\n  \/\/ this is used for sub pixel precision\n  var Z = 10;\n  var Z2 = Z \/ 2;\n\n  \/**\n   * This funtion is assigned to the <canvas> elements as element.getContext().\n   * @this {HTMLElement}\n   * @return {CanvasRenderingContext2D_}\n   *\/\n  function getContext() {\n    return this.context_ ||\n        (this.context_ = new CanvasRenderingContext2D_(this));\n  }\n\n  var slice = Array.prototype.slice;\n\n  \/**\n   * Binds a function to an object. The returned function will always use the\n   * passed in {@code obj} as {@code this}.\n   *\n   * Example:\n   *\n   *   g = bind(f, obj, a, b)\n   *   g(c, d) \/\/ will do f.call(obj, a, b, c, d)\n   *\n   * @param {Function} f The function to bind the object to\n   * @param {Object} obj The object that should act as this when the function\n   *     is called\n   * @param {*} var_args Rest arguments that will be used as the initial\n   *     arguments when the function is called\n   * @return {Function} A new function that has bound this\n   *\/\n  function bind(f, obj, var_args) {\n    var a = slice.call(arguments, 2);\n    return function() {\n      return f.apply(obj, a.concat(slice.call(arguments)));\n    };\n  }\n\n  function encodeHtmlAttribute(s) {\n    return String(s).replace(\/&\/g, '&amp;').replace(\/\"\/g, '&quot;');\n  }\n\n  function addNamespacesAndStylesheet(doc) {\n    \/\/ create xmlns\n    if (!doc.namespaces['g_vml_']) {\n      doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',\n                         '#default#VML');\n\n    }\n    if (!doc.namespaces['g_o_']) {\n      doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',\n                         '#default#VML');\n    }\n\n    \/\/ Setup default CSS.  Only add one style sheet per document\n    if (!doc.styleSheets['ex_canvas_']) {\n      var ss = doc.createStyleSheet();\n      ss.owningElement.id = 'ex_canvas_';\n      ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +\n          \/\/ default size is 300x150 in Gecko and Opera\n          'text-align:left;width:300px;height:150px}';\n    }\n  }\n\n  \/\/ Add namespaces and stylesheet at startup.\n  addNamespacesAndStylesheet(document);\n\n  var G_vmlCanvasManager_ = {\n    init: function(opt_doc) {\n      if (\/MSIE\/.test(navigator.userAgent) && !window.opera) {\n        var doc = opt_doc || document;\n        \/\/ Create a dummy element so that IE will allow canvas elements to be\n        \/\/ recognized.\n        doc.createElement('canvas');\n        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));\n      }\n    },\n\n    init_: function(doc) {\n      \/\/ find all canvas elements\n      var els = doc.getElementsByTagName('canvas');\n      for (var i = 0; i < els.length; i++) {\n        this.initElement(els[i]);\n      }\n    },\n\n    \/**\n     * Public initializes a canvas element so that it can be used as canvas\n     * element from now on. This is called automatically before the page is\n     * loaded but if you are creating elements using createElement you need to\n     * make sure this is called on the element.\n     * @param {HTMLElement} el The canvas element to initialize.\n     * @return {HTMLElement} the element that was created.\n     *\/\n    initElement: function(el) {\n      if (!el.getContext) {\n        el.getContext = getContext;\n\n        \/\/ Add namespaces and stylesheet to document of the element.\n        addNamespacesAndStylesheet(el.ownerDocument);\n\n        \/\/ Remove fallback content. There is no way to hide text nodes so we\n        \/\/ just remove all childNodes. We could hide all elements and remove\n        \/\/ text nodes but who really cares about the fallback content.\n        el.innerHTML = '';\n\n        \/\/ do not use inline function because that will leak memory\n        el.attachEvent('onpropertychange', onPropertyChange);\n        el.attachEvent('onresize', onResize);\n\n        var attrs = el.attributes;\n        if (attrs.width && attrs.width.specified) {\n          \/\/ TODO: use runtimeStyle and coordsize\n          \/\/ el.getContext().setWidth_(attrs.width.nodeValue);\n          el.style.width = attrs.width.nodeValue + 'px';\n        } else {\n          el.width = el.clientWidth;\n        }\n        if (attrs.height && attrs.height.specified) {\n          \/\/ TODO: use runtimeStyle and coordsize\n          \/\/ el.getContext().setHeight_(attrs.height.nodeValue);\n          el.style.height = attrs.height.nodeValue + 'px';\n        } else {\n          el.height = el.clientHeight;\n        }\n        \/\/el.getContext().setCoordsize_()\n      }\n      return el;\n    }\n  };\n\n  function onPropertyChange(e) {\n    var el = e.srcElement;\n\n    switch (e.propertyName) {\n      case 'width':\n        el.getContext().clearRect();\n        el.style.width = el.attributes.width.nodeValue + 'px';\n        \/\/ In IE8 this does not trigger onresize.\n        el.firstChild.style.width =  el.clientWidth + 'px';\n        break;\n      case 'height':\n        el.getContext().clearRect();\n        el.style.height = el.attributes.height.nodeValue + 'px';\n        el.firstChild.style.height = el.clientHeight + 'px';\n        break;\n    }\n  }\n\n  function onResize(e) {\n    var el = e.srcElement;\n    if (el.firstChild) {\n      el.firstChild.style.width =  el.clientWidth + 'px';\n      el.firstChild.style.height = el.clientHeight + 'px';\n    }\n  }\n\n  G_vmlCanvasManager_.init();\n\n  \/\/ precompute \"00\" to \"FF\"\n  var decToHex = [];\n  for (var i = 0; i < 16; i++) {\n    for (var j = 0; j < 16; j++) {\n      decToHex[i * 16 + j] = i.toString(16) + j.toString(16);\n    }\n  }\n\n  function createMatrixIdentity() {\n    return [\n      [1, 0, 0],\n      [0, 1, 0],\n      [0, 0, 1]\n    ];\n  }\n\n  function matrixMultiply(m1, m2) {\n    var result = createMatrixIdentity();\n\n    for (var x = 0; x < 3; x++) {\n      for (var y = 0; y < 3; y++) {\n        var sum = 0;\n\n        for (var z = 0; z < 3; z++) {\n          sum += m1[x][z] * m2[z][y];\n        }\n\n        result[x][y] = sum;\n      }\n    }\n    return result;\n  }\n\n  function copyState(o1, o2) {\n    o2.fillStyle     = o1.fillStyle;\n    o2.lineCap       = o1.lineCap;\n    o2.lineJoin      = o1.lineJoin;\n    o2.lineWidth     = o1.lineWidth;\n    o2.miterLimit    = o1.miterLimit;\n    o2.shadowBlur    = o1.shadowBlur;\n    o2.shadowColor   = o1.shadowColor;\n    o2.shadowOffsetX = o1.shadowOffsetX;\n    o2.shadowOffsetY = o1.shadowOffsetY;\n    o2.strokeStyle   = o1.strokeStyle;\n    o2.globalAlpha   = o1.globalAlpha;\n    o2.font          = o1.font;\n    o2.textAlign     = o1.textAlign;\n    o2.textBaseline  = o1.textBaseline;\n    o2.arcScaleX_    = o1.arcScaleX_;\n    o2.arcScaleY_    = o1.arcScaleY_;\n    o2.lineScale_    = o1.lineScale_;\n  }\n\n  var colorData = {\n    aliceblue: '#F0F8FF',\n    antiquewhite: '#FAEBD7',\n    aquamarine: '#7FFFD4',\n    azure: '#F0FFFF',\n    beige: '#F5F5DC',\n    bisque: '#FFE4C4',\n    black: '#000000',\n    blanchedalmond: '#FFEBCD',\n    blueviolet: '#8A2BE2',\n    brown: '#A52A2A',\n    burlywood: '#DEB887',\n    cadetblue: '#5F9EA0',\n    chartreuse: '#7FFF00',\n    chocolate: '#D2691E',\n    coral: '#FF7F50',\n    cornflowerblue: '#6495ED',\n    cornsilk: '#FFF8DC',\n    crimson: '#DC143C',\n    cyan: '#00FFFF',\n    darkblue: '#00008B',\n    darkcyan: '#008B8B',\n    darkgoldenrod: '#B8860B',\n    darkgray: '#A9A9A9',\n    darkgreen: '#006400',\n    darkgrey: '#A9A9A9',\n    darkkhaki: '#BDB76B',\n    darkmagenta: '#8B008B',\n    darkolivegreen: '#556B2F',\n    darkorange: '#FF8C00',\n    darkorchid: '#9932CC',\n    darkred: '#8B0000',\n    darksalmon: '#E9967A',\n    darkseagreen: '#8FBC8F',\n    darkslateblue: '#483D8B',\n    darkslategray: '#2F4F4F',\n    darkslategrey: '#2F4F4F',\n    darkturquoise: '#00CED1',\n    darkviolet: '#9400D3',\n    deeppink: '#FF1493',\n    deepskyblue: '#00BFFF',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1E90FF',\n    firebrick: '#B22222',\n    floralwhite: '#FFFAF0',\n    forestgreen: '#228B22',\n    gainsboro: '#DCDCDC',\n    ghostwhite: '#F8F8FF',\n    gold: '#FFD700',\n    goldenrod: '#DAA520',\n    grey: '#808080',\n    greenyellow: '#ADFF2F',\n    honeydew: '#F0FFF0',\n    hotpink: '#FF69B4',\n    indianred: '#CD5C5C',\n    indigo: '#4B0082',\n    ivory: '#FFFFF0',\n    khaki: '#F0E68C',\n    lavender: '#E6E6FA',\n    lavenderblush: '#FFF0F5',\n    lawngreen: '#7CFC00',\n    lemonchiffon: '#FFFACD',\n    lightblue: '#ADD8E6',\n    lightcoral: '#F08080',\n    lightcyan: '#E0FFFF',\n    lightgoldenrodyellow: '#FAFAD2',\n    lightgreen: '#90EE90',\n    lightgrey: '#D3D3D3',\n    lightpink: '#FFB6C1',\n    lightsalmon: '#FFA07A',\n    lightseagreen: '#20B2AA',\n    lightskyblue: '#87CEFA',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#B0C4DE',\n    lightyellow: '#FFFFE0',\n    limegreen: '#32CD32',\n    linen: '#FAF0E6',\n    magenta: '#FF00FF',\n    mediumaquamarine: '#66CDAA',\n    mediumblue: '#0000CD',\n    mediumorchid: '#BA55D3',\n    mediumpurple: '#9370DB',\n    mediumseagreen: '#3CB371',\n    mediumslateblue: '#7B68EE',\n    mediumspringgreen: '#00FA9A',\n    mediumturquoise: '#48D1CC',\n    mediumvioletred: '#C71585',\n    midnightblue: '#191970',\n    mintcream: '#F5FFFA',\n    mistyrose: '#FFE4E1',\n    moccasin: '#FFE4B5',\n    navajowhite: '#FFDEAD',\n    oldlace: '#FDF5E6',\n    olivedrab: '#6B8E23',\n    orange: '#FFA500',\n    orangered: '#FF4500',\n    orchid: '#DA70D6',\n    palegoldenrod: '#EEE8AA',\n    palegreen: '#98FB98',\n    paleturquoise: '#AFEEEE',\n    palevioletred: '#DB7093',\n    papayawhip: '#FFEFD5',\n    peachpuff: '#FFDAB9',\n    peru: '#CD853F',\n    pink: '#FFC0CB',\n    plum: '#DDA0DD',\n    powderblue: '#B0E0E6',\n    rosybrown: '#BC8F8F',\n    royalblue: '#4169E1',\n    saddlebrown: '#8B4513',\n    salmon: '#FA8072',\n    sandybrown: '#F4A460',\n    seagreen: '#2E8B57',\n    seashell: '#FFF5EE',\n    sienna: '#A0522D',\n    skyblue: '#87CEEB',\n    slateblue: '#6A5ACD',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#FFFAFA',\n    springgreen: '#00FF7F',\n    steelblue: '#4682B4',\n    tan: '#D2B48C',\n    thistle: '#D8BFD8',\n    tomato: '#FF6347',\n    turquoise: '#40E0D0',\n    violet: '#EE82EE',\n    wheat: '#F5DEB3',\n    whitesmoke: '#F5F5F5',\n    yellowgreen: '#9ACD32'\n  };\n\n\n  function getRgbHslContent(styleString) {\n    var start = styleString.indexOf('(', 3);\n    var end = styleString.indexOf(')', start + 1);\n    var parts = styleString.substring(start + 1, end).split(',');\n    \/\/ add alpha if needed\n    if (parts.length == 4 && styleString.substr(3, 1) == 'a') {\n      alpha = Number(parts[3]);\n    } else {\n      parts[3] = 1;\n    }\n    return parts;\n  }\n\n  function percent(s) {\n    return parseFloat(s) \/ 100;\n  }\n\n  function clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  }\n\n  function hslToRgb(parts){\n    var r, g, b;\n    h = parseFloat(parts[0]) \/ 360 % 360;\n    if (h < 0)\n      h++;\n    s = clamp(percent(parts[1]), 0, 1);\n    l = clamp(percent(parts[2]), 0, 1);\n    if (s == 0) {\n      r = g = b = l; \/\/ achromatic\n    } else {\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = hueToRgb(p, q, h + 1 \/ 3);\n      g = hueToRgb(p, q, h);\n      b = hueToRgb(p, q, h - 1 \/ 3);\n    }\n\n    return '#' + decToHex[Math.floor(r * 255)] +\n        decToHex[Math.floor(g * 255)] +\n        decToHex[Math.floor(b * 255)];\n  }\n\n  function hueToRgb(m1, m2, h) {\n    if (h < 0)\n      h++;\n    if (h > 1)\n      h--;\n\n    if (6 * h < 1)\n      return m1 + (m2 - m1) * 6 * h;\n    else if (2 * h < 1)\n      return m2;\n    else if (3 * h < 2)\n      return m1 + (m2 - m1) * (2 \/ 3 - h) * 6;\n    else\n      return m1;\n  }\n\n  function processStyle(styleString) {\n    var str, alpha = 1;\n\n    styleString = String(styleString);\n    if (styleString.charAt(0) == '#') {\n      str = styleString;\n    } else if (\/^rgb\/.test(styleString)) {\n      var parts = getRgbHslContent(styleString);\n      var str = '#', n;\n      for (var i = 0; i < 3; i++) {\n        if (parts[i].indexOf('%') != -1) {\n          n = Math.floor(percent(parts[i]) * 255);\n        } else {\n          n = Number(parts[i]);\n        }\n        str += decToHex[clamp(n, 0, 255)];\n      }\n      alpha = parts[3];\n    } else if (\/^hsl\/.test(styleString)) {\n      var parts = getRgbHslContent(styleString);\n      str = hslToRgb(parts);\n      alpha = parts[3];\n    } else {\n      str = colorData[styleString] || styleString;\n    }\n    return {color: str, alpha: alpha};\n  }\n\n  var DEFAULT_STYLE = {\n    style: 'normal',\n    variant: 'normal',\n    weight: 'normal',\n    size: 10,\n    family: 'sans-serif'\n  };\n\n  \/\/ Internal text style cache\n  var fontStyleCache = {};\n\n  function processFontStyle(styleString) {\n    if (fontStyleCache[styleString]) {\n      return fontStyleCache[styleString];\n    }\n\n    var el = document.createElement('div');\n    var style = el.style;\n    try {\n      style.font = styleString;\n    } catch (ex) {\n      \/\/ Ignore failures to set to invalid font.\n    }\n\n    return fontStyleCache[styleString] = {\n      style: style.fontStyle || DEFAULT_STYLE.style,\n      variant: style.fontVariant || DEFAULT_STYLE.variant,\n      weight: style.fontWeight || DEFAULT_STYLE.weight,\n      size: style.fontSize || DEFAULT_STYLE.size,\n      family: style.fontFamily || DEFAULT_STYLE.family\n    };\n  }\n\n  function getComputedStyle(style, element) {\n    var computedStyle = {};\n\n    for (var p in style) {\n      computedStyle[p] = style[p];\n    }\n\n    \/\/ Compute the size\n    var canvasFontSize = parseFloat(element.currentStyle.fontSize),\n        fontSize = parseFloat(style.size);\n\n    if (typeof style.size == 'number') {\n      computedStyle.size = style.size;\n    } else if (style.size.indexOf('px') != -1) {\n      computedStyle.size = fontSize;\n    } else if (style.size.indexOf('em') != -1) {\n      computedStyle.size = canvasFontSize * fontSize;\n    } else if(style.size.indexOf('%') != -1) {\n      computedStyle.size = (canvasFontSize \/ 100) * fontSize;\n    } else if (style.size.indexOf('pt') != -1) {\n      computedStyle.size = fontSize \/ .75;\n    } else {\n      computedStyle.size = canvasFontSize;\n    }\n\n    \/\/ Different scaling between normal text and VML text. This was found using\n    \/\/ trial and error to get the same size as non VML text.\n    computedStyle.size *= 0.981;\n\n    return computedStyle;\n  }\n\n  function buildStyle(style) {\n    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +\n        style.size + 'px ' + style.family;\n  }\n\n  function processLineCap(lineCap) {\n    switch (lineCap) {\n      case 'butt':\n        return 'flat';\n      case 'round':\n        return 'round';\n      case 'square':\n      default:\n        return 'square';\n    }\n  }\n\n  \/**\n   * This class implements CanvasRenderingContext2D interface as described by\n   * the WHATWG.\n   * @param {HTMLElement} surfaceElement The element that the 2D context should\n   * be associated with\n   *\/\n  function CanvasRenderingContext2D_(surfaceElement) {\n    this.m_ = createMatrixIdentity();\n\n    this.mStack_ = [];\n    this.aStack_ = [];\n    this.currentPath_ = [];\n\n    \/\/ Canvas context properties\n    this.strokeStyle = '#000';\n    this.fillStyle = '#000';\n\n    this.lineWidth = 1;\n    this.lineJoin = 'miter';\n    this.lineCap = 'butt';\n    this.miterLimit = Z * 1;\n    this.globalAlpha = 1;\n    this.font = '10px sans-serif';\n    this.textAlign = 'left';\n    this.textBaseline = 'alphabetic';\n    this.canvas = surfaceElement;\n\n    var el = surfaceElement.ownerDocument.createElement('div');\n    el.style.width =  surfaceElement.clientWidth + 'px';\n    el.style.height = surfaceElement.clientHeight + 'px';\n    el.style.overflow = 'hidden';\n    el.style.position = 'absolute';\n    surfaceElement.appendChild(el);\n\n    this.element_ = el;\n    this.arcScaleX_ = 1;\n    this.arcScaleY_ = 1;\n    this.lineScale_ = 1;\n  }\n\n  var contextPrototype = CanvasRenderingContext2D_.prototype;\n  contextPrototype.clearRect = function() {\n    if (this.textMeasureEl_) {\n      this.textMeasureEl_.removeNode(true);\n      this.textMeasureEl_ = null;\n    }\n    this.element_.innerHTML = '';\n  };\n\n  contextPrototype.beginPath = function() {\n    \/\/ TODO: Branch current matrix so that save\/restore has no effect\n    \/\/       as per safari docs.\n    this.currentPath_ = [];\n  };\n\n  contextPrototype.moveTo = function(aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});\n    this.currentX_ = p.x;\n    this.currentY_ = p.y;\n  };\n\n  contextPrototype.lineTo = function(aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});\n\n    this.currentX_ = p.x;\n    this.currentY_ = p.y;\n  };\n\n  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,\n                                            aCP2x, aCP2y,\n                                            aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    var cp1 = this.getCoords_(aCP1x, aCP1y);\n    var cp2 = this.getCoords_(aCP2x, aCP2y);\n    bezierCurveTo(this, cp1, cp2, p);\n  };\n\n  \/\/ Helper function that takes the already fixed cordinates.\n  function bezierCurveTo(self, cp1, cp2, p) {\n    self.currentPath_.push({\n      type: 'bezierCurveTo',\n      cp1x: cp1.x,\n      cp1y: cp1.y,\n      cp2x: cp2.x,\n      cp2y: cp2.y,\n      x: p.x,\n      y: p.y\n    });\n    self.currentX_ = p.x;\n    self.currentY_ = p.y;\n  }\n\n  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {\n    \/\/ the following is lifted almost directly from\n    \/\/ http:\/\/developer.mozilla.org\/en\/docs\/Canvas_tutorial:Drawing_shapes\n\n    var cp = this.getCoords_(aCPx, aCPy);\n    var p = this.getCoords_(aX, aY);\n\n    var cp1 = {\n      x: this.currentX_ + 2.0 \/ 3.0 * (cp.x - this.currentX_),\n      y: this.currentY_ + 2.0 \/ 3.0 * (cp.y - this.currentY_)\n    };\n    var cp2 = {\n      x: cp1.x + (p.x - this.currentX_) \/ 3.0,\n      y: cp1.y + (p.y - this.currentY_) \/ 3.0\n    };\n\n    bezierCurveTo(this, cp1, cp2, p);\n  };\n\n  contextPrototype.arc = function(aX, aY, aRadius,\n                                  aStartAngle, aEndAngle, aClockwise) {\n    aRadius *= Z;\n    var arcType = aClockwise ? 'at' : 'wa';\n\n    var xStart = aX + mc(aStartAngle) * aRadius - Z2;\n    var yStart = aY + ms(aStartAngle) * aRadius - Z2;\n\n    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;\n    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;\n\n    \/\/ IE won't render arches drawn counter clockwise if xStart == xEnd.\n    if (xStart == xEnd && !aClockwise) {\n      xStart += 0.125; \/\/ Offset xStart by 1\/80 of a pixel. Use something\n                       \/\/ that can be represented in binary\n    }\n\n    var p = this.getCoords_(aX, aY);\n    var pStart = this.getCoords_(xStart, yStart);\n    var pEnd = this.getCoords_(xEnd, yEnd);\n\n    this.currentPath_.push({type: arcType,\n                           x: p.x,\n                           y: p.y,\n                           radius: aRadius,\n                           xStart: pStart.x,\n                           yStart: pStart.y,\n                           xEnd: pEnd.x,\n                           yEnd: pEnd.y});\n\n  };\n\n  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n  };\n\n  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {\n    var oldPath = this.currentPath_;\n    this.beginPath();\n\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n    this.stroke();\n\n    this.currentPath_ = oldPath;\n  };\n\n  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {\n    var oldPath = this.currentPath_;\n    this.beginPath();\n\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n    this.fill();\n\n    this.currentPath_ = oldPath;\n  };\n\n  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {\n    var gradient = new CanvasGradient_('gradient');\n    gradient.x0_ = aX0;\n    gradient.y0_ = aY0;\n    gradient.x1_ = aX1;\n    gradient.y1_ = aY1;\n    return gradient;\n  };\n\n  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,\n                                                   aX1, aY1, aR1) {\n    var gradient = new CanvasGradient_('gradientradial');\n    gradient.x0_ = aX0;\n    gradient.y0_ = aY0;\n    gradient.r0_ = aR0;\n    gradient.x1_ = aX1;\n    gradient.y1_ = aY1;\n    gradient.r1_ = aR1;\n    return gradient;\n  };\n\n  contextPrototype.drawImage = function(image, var_args) {\n    var dx, dy, dw, dh, sx, sy, sw, sh;\n\n    \/\/ to find the original width we overide the width and height\n    var oldRuntimeWidth = image.runtimeStyle.width;\n    var oldRuntimeHeight = image.runtimeStyle.height;\n    image.runtimeStyle.width = 'auto';\n    image.runtimeStyle.height = 'auto';\n\n    \/\/ get the original size\n    var w = image.width;\n    var h = image.height;\n\n    \/\/ and remove overides\n    image.runtimeStyle.width = oldRuntimeWidth;\n    image.runtimeStyle.height = oldRuntimeHeight;\n\n    if (arguments.length == 3) {\n      dx = arguments[1];\n      dy = arguments[2];\n      sx = sy = 0;\n      sw = dw = w;\n      sh = dh = h;\n    } else if (arguments.length == 5) {\n      dx = arguments[1];\n      dy = arguments[2];\n      dw = arguments[3];\n      dh = arguments[4];\n      sx = sy = 0;\n      sw = w;\n      sh = h;\n    } else if (arguments.length == 9) {\n      sx = arguments[1];\n      sy = arguments[2];\n      sw = arguments[3];\n      sh = arguments[4];\n      dx = arguments[5];\n      dy = arguments[6];\n      dw = arguments[7];\n      dh = arguments[8];\n    } else {\n      throw Error('Invalid number of arguments');\n    }\n\n    var d = this.getCoords_(dx, dy);\n\n    var w2 = sw \/ 2;\n    var h2 = sh \/ 2;\n\n    var vmlStr = [];\n\n    var W = 10;\n    var H = 10;\n\n    \/\/ For some reason that I've now forgotten, using divs didn't work\n    vmlStr.push(' <g_vml_:group',\n                ' coordsize=\"', Z * W, ',', Z * H, '\"',\n                ' coordorigin=\"0,0\"' ,\n                ' style=\"width:', W, 'px;height:', H, 'px;position:absolute;');\n\n    \/\/ If filters are necessary (rotation exists), create them\n    \/\/ filters are bog-slow, so only create them if abbsolutely necessary\n    \/\/ The following check doesn't account for skews (which don't exist\n    \/\/ in the canvas spec (yet) anyway.\n\n    if (this.m_[0][0] != 1 || this.m_[0][1] ||\n        this.m_[1][1] != 1 || this.m_[1][0]) {\n      var filter = [];\n\n      \/\/ Note the 12\/21 reversal\n      filter.push('M11=', this.m_[0][0], ',',\n                  'M12=', this.m_[1][0], ',',\n                  'M21=', this.m_[0][1], ',',\n                  'M22=', this.m_[1][1], ',',\n                  'Dx=', mr(d.x \/ Z), ',',\n                  'Dy=', mr(d.y \/ Z), '');\n\n      \/\/ Bounding box calculation (need to minimize displayed area so that\n      \/\/ filters don't waste time on unused pixels.\n      var max = d;\n      var c2 = this.getCoords_(dx + dw, dy);\n      var c3 = this.getCoords_(dx, dy + dh);\n      var c4 = this.getCoords_(dx + dw, dy + dh);\n\n      max.x = m.max(max.x, c2.x, c3.x, c4.x);\n      max.y = m.max(max.y, c2.y, c3.y, c4.y);\n\n      vmlStr.push('padding:0 ', mr(max.x \/ Z), 'px ', mr(max.y \/ Z),\n                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',\n                  filter.join(''), \", sizingmethod='clip');\");\n\n    } else {\n      vmlStr.push('top:', mr(d.y \/ Z), 'px;left:', mr(d.x \/ Z), 'px;');\n    }\n\n    vmlStr.push(' \">' ,\n                '<g_vml_:image src=\"', image.src, '\"',\n                ' style=\"width:', Z * dw, 'px;',\n                ' height:', Z * dh, 'px\"',\n                ' cropleft=\"', sx \/ w, '\"',\n                ' croptop=\"', sy \/ h, '\"',\n                ' cropright=\"', (w - sx - sw) \/ w, '\"',\n                ' cropbottom=\"', (h - sy - sh) \/ h, '\"',\n                ' \/>',\n                '<\/g_vml_:group>');\n\n    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));\n  };\n\n  contextPrototype.stroke = function(aFill) {\n    var W = 10;\n    var H = 10;\n    \/\/ Divide the shape into chunks if it's too long because IE has a limit\n    \/\/ somewhere for how long a VML shape can be. This simple division does\n    \/\/ not work with fills, only strokes, unfortunately.\n    var chunkSize = 5000;\n\n    var min = {x: null, y: null};\n    var max = {x: null, y: null};\n\n    for (var j = 0; j < this.currentPath_.length; j += chunkSize) {\n      var lineStr = [];\n      var lineOpen = false;\n\n      lineStr.push('<g_vml_:shape',\n                   ' filled=\"', !!aFill, '\"',\n                   ' style=\"position:absolute;width:', W, 'px;height:', H, 'px;\"',\n                   ' coordorigin=\"0,0\"',\n                   ' coordsize=\"', Z * W, ',', Z * H, '\"',\n                   ' stroked=\"', !aFill, '\"',\n                   ' path=\"');\n\n      var newSeq = false;\n\n      for (var i = j; i < Math.min(j + chunkSize, this.currentPath_.length); i++) {\n        if (i % chunkSize == 0 && i > 0) { \/\/ move into position for next chunk\n          lineStr.push(' m ', mr(this.currentPath_[i-1].x), ',', mr(this.currentPath_[i-1].y));\n        }\n\n        var p = this.currentPath_[i];\n        var c;\n\n        switch (p.type) {\n          case 'moveTo':\n            c = p;\n            lineStr.push(' m ', mr(p.x), ',', mr(p.y));\n            break;\n          case 'lineTo':\n            lineStr.push(' l ', mr(p.x), ',', mr(p.y));\n            break;\n          case 'close':\n            lineStr.push(' x ');\n            p = null;\n            break;\n          case 'bezierCurveTo':\n            lineStr.push(' c ',\n                         mr(p.cp1x), ',', mr(p.cp1y), ',',\n                         mr(p.cp2x), ',', mr(p.cp2y), ',',\n                         mr(p.x), ',', mr(p.y));\n            break;\n          case 'at':\n          case 'wa':\n            lineStr.push(' ', p.type, ' ',\n                         mr(p.x - this.arcScaleX_ * p.radius), ',',\n                         mr(p.y - this.arcScaleY_ * p.radius), ' ',\n                         mr(p.x + this.arcScaleX_ * p.radius), ',',\n                         mr(p.y + this.arcScaleY_ * p.radius), ' ',\n                         mr(p.xStart), ',', mr(p.yStart), ' ',\n                         mr(p.xEnd), ',', mr(p.yEnd));\n            break;\n        }\n  \n  \n        \/\/ TODO: Following is broken for curves due to\n        \/\/       move to proper paths.\n  \n        \/\/ Figure out dimensions so we can do gradient fills\n        \/\/ properly\n        if (p) {\n          if (min.x == null || p.x < min.x) {\n            min.x = p.x;\n          }\n          if (max.x == null || p.x > max.x) {\n            max.x = p.x;\n          }\n          if (min.y == null || p.y < min.y) {\n            min.y = p.y;\n          }\n          if (max.y == null || p.y > max.y) {\n            max.y = p.y;\n          }\n        }\n      }\n      lineStr.push(' \">');\n  \n      if (!aFill) {\n        appendStroke(this, lineStr);\n      } else {\n        appendFill(this, lineStr, min, max);\n      }\n  \n      lineStr.push('<\/g_vml_:shape>');\n  \n      this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\n    }\n  };\n\n  function appendStroke(ctx, lineStr) {\n    var a = processStyle(ctx.strokeStyle);\n    var color = a.color;\n    var opacity = a.alpha * ctx.globalAlpha;\n    var lineWidth = ctx.lineScale_ * ctx.lineWidth;\n\n    \/\/ VML cannot correctly render a line if the width is less than 1px.\n    \/\/ In that case, we dilute the color to make the line look thinner.\n    if (lineWidth < 1) {\n      opacity *= lineWidth;\n    }\n\n    lineStr.push(\n      '<g_vml_:stroke',\n      ' opacity=\"', opacity, '\"',\n      ' joinstyle=\"', ctx.lineJoin, '\"',\n      ' miterlimit=\"', ctx.miterLimit, '\"',\n      ' endcap=\"', processLineCap(ctx.lineCap), '\"',\n      ' weight=\"', lineWidth, 'px\"',\n      ' color=\"', color, '\" \/>'\n    );\n  }\n\n  function appendFill(ctx, lineStr, min, max) {\n    var fillStyle = ctx.fillStyle;\n    var arcScaleX = ctx.arcScaleX_;\n    var arcScaleY = ctx.arcScaleY_;\n    var width = max.x - min.x;\n    var height = max.y - min.y;\n    if (fillStyle instanceof CanvasGradient_) {\n      \/\/ TODO: Gradients transformed with the transformation matrix.\n      var angle = 0;\n      var focus = {x: 0, y: 0};\n\n      \/\/ additional offset\n      var shift = 0;\n      \/\/ scale factor for offset\n      var expansion = 1;\n\n      if (fillStyle.type_ == 'gradient') {\n        var x0 = fillStyle.x0_ \/ arcScaleX;\n        var y0 = fillStyle.y0_ \/ arcScaleY;\n        var x1 = fillStyle.x1_ \/ arcScaleX;\n        var y1 = fillStyle.y1_ \/ arcScaleY;\n        var p0 = ctx.getCoords_(x0, y0);\n        var p1 = ctx.getCoords_(x1, y1);\n        var dx = p1.x - p0.x;\n        var dy = p1.y - p0.y;\n        angle = Math.atan2(dx, dy) * 180 \/ Math.PI;\n\n        \/\/ The angle should be a non-negative number.\n        if (angle < 0) {\n          angle += 360;\n        }\n\n        \/\/ Very small angles produce an unexpected result because they are\n        \/\/ converted to a scientific notation string.\n        if (angle < 1e-6) {\n          angle = 0;\n        }\n      } else {\n        var p0 = ctx.getCoords_(fillStyle.x0_, fillStyle.y0_);\n        focus = {\n          x: (p0.x - min.x) \/ width,\n          y: (p0.y - min.y) \/ height\n        };\n\n        width  \/= arcScaleX * Z;\n        height \/= arcScaleY * Z;\n        var dimension = m.max(width, height);\n        shift = 2 * fillStyle.r0_ \/ dimension;\n        expansion = 2 * fillStyle.r1_ \/ dimension - shift;\n      }\n\n      \/\/ We need to sort the color stops in ascending order by offset,\n      \/\/ otherwise IE won't interpret it correctly.\n      var stops = fillStyle.colors_;\n      stops.sort(function(cs1, cs2) {\n        return cs1.offset - cs2.offset;\n      });\n\n      var length = stops.length;\n      var color1 = stops[0].color;\n      var color2 = stops[length - 1].color;\n      var opacity1 = stops[0].alpha * ctx.globalAlpha;\n      var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;\n\n      var colors = [];\n      for (var i = 0; i < length; i++) {\n        var stop = stops[i];\n        colors.push(stop.offset * expansion + shift + ' ' + stop.color);\n      }\n\n      \/\/ When colors attribute is used, the meanings of opacity and o:opacity2\n      \/\/ are reversed.\n      lineStr.push('<g_vml_:fill type=\"', fillStyle.type_, '\"',\n                   ' method=\"none\" focus=\"100%\"',\n                   ' color=\"', color1, '\"',\n                   ' color2=\"', color2, '\"',\n                   ' colors=\"', colors.join(','), '\"',\n                   ' opacity=\"', opacity2, '\"',\n                   ' g_o_:opacity2=\"', opacity1, '\"',\n                   ' angle=\"', angle, '\"',\n                   ' focusposition=\"', focus.x, ',', focus.y, '\" \/>');\n    } else if (fillStyle instanceof CanvasPattern_) {\n      if (width && height) {\n        var deltaLeft = -min.x;\n        var deltaTop = -min.y;\n        lineStr.push('<g_vml_:fill',\n                     ' position=\"',\n                     deltaLeft \/ width * arcScaleX * arcScaleX, ',',\n                     deltaTop \/ height * arcScaleY * arcScaleY, '\"',\n                     ' type=\"tile\"',\n                     \/\/ TODO: Figure out the correct size to fit the scale.\n                     \/\/' size=\"', w, 'px ', h, 'px\"',\n                     ' src=\"', fillStyle.src_, '\" \/>');\n       }\n    } else {\n      var a = processStyle(ctx.fillStyle);\n      var color = a.color;\n      var opacity = a.alpha * ctx.globalAlpha;\n      lineStr.push('<g_vml_:fill color=\"', color, '\" opacity=\"', opacity,\n                   '\" \/>');\n    }\n  }\n\n  contextPrototype.fill = function() {\n    this.stroke(true);\n  };\n\n  contextPrototype.closePath = function() {\n    this.currentPath_.push({type: 'close'});\n  };\n\n  \/**\n   * @private\n   *\/\n  contextPrototype.getCoords_ = function(aX, aY) {\n    var m = this.m_;\n    return {\n      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,\n      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2\n    };\n  };\n\n  contextPrototype.save = function() {\n    var o = {};\n    copyState(this, o);\n    this.aStack_.push(o);\n    this.mStack_.push(this.m_);\n    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);\n  };\n\n  contextPrototype.restore = function() {\n    if (this.aStack_.length) {\n      copyState(this.aStack_.pop(), this);\n      this.m_ = this.mStack_.pop();\n    }\n  };\n\n  function matrixIsFinite(m) {\n    return isFinite(m[0][0]) && isFinite(m[0][1]) &&\n        isFinite(m[1][0]) && isFinite(m[1][1]) &&\n        isFinite(m[2][0]) && isFinite(m[2][1]);\n  }\n\n  function setM(ctx, m, updateLineScale) {\n    if (!matrixIsFinite(m)) {\n      return;\n    }\n    ctx.m_ = m;\n\n    if (updateLineScale) {\n      \/\/ Get the line scale.\n      \/\/ Determinant of this.m_ means how much the area is enlarged by the\n      \/\/ transformation. So its square root can be used as a scale factor\n      \/\/ for width.\n      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];\n      ctx.lineScale_ = sqrt(abs(det));\n    }\n  }\n\n  contextPrototype.translate = function(aX, aY) {\n    var m1 = [\n      [1,  0,  0],\n      [0,  1,  0],\n      [aX, aY, 1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), false);\n  };\n\n  contextPrototype.rotate = function(aRot) {\n    var c = mc(aRot);\n    var s = ms(aRot);\n\n    var m1 = [\n      [c,  s, 0],\n      [-s, c, 0],\n      [0,  0, 1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), false);\n  };\n\n  contextPrototype.scale = function(aX, aY) {\n    this.arcScaleX_ *= aX;\n    this.arcScaleY_ *= aY;\n    var m1 = [\n      [aX, 0,  0],\n      [0,  aY, 0],\n      [0,  0,  1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), true);\n  };\n\n  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {\n    var m1 = [\n      [m11, m12, 0],\n      [m21, m22, 0],\n      [dx,  dy,  1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), true);\n  };\n\n  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {\n    var m = [\n      [m11, m12, 0],\n      [m21, m22, 0],\n      [dx,  dy,  1]\n    ];\n\n    setM(this, m, true);\n  };\n\n  \/**\n   * The text drawing function.\n   * The maxWidth argument isn't taken in account, since no browser supports\n   * it yet.\n   *\/\n  contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {\n    var m = this.m_,\n        delta = 1000,\n        left = 0,\n        right = delta,\n        offset = {x: 0, y: 0},\n        lineStr = [];\n\n    var fontStyle = getComputedStyle(processFontStyle(this.font),\n                                     this.element_);\n\n    var fontStyleString = buildStyle(fontStyle);\n\n    var elementStyle = this.element_.currentStyle;\n    var textAlign = this.textAlign.toLowerCase();\n    switch (textAlign) {\n      case 'left':\n      case 'center':\n      case 'right':\n        break;\n      case 'end':\n        textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';\n        break;\n      case 'start':\n        textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';\n        break;\n      default:\n        textAlign = 'left';\n    }\n\n    \/\/ 1.75 is an arbitrary number, as there is no info about the text baseline\n    switch (this.textBaseline) {\n      case 'hanging':\n      case 'top':\n        offset.y = fontStyle.size \/ 1.75;\n        break;\n      case 'middle':\n        break;\n      default:\n      case null:\n      case 'alphabetic':\n      case 'ideographic':\n      case 'bottom':\n        offset.y = -fontStyle.size \/ 2.25;\n        break;\n    }\n\n    switch(textAlign) {\n      case 'right':\n        left = delta;\n        right = 0.05;\n        break;\n      case 'center':\n        left = right = delta \/ 2;\n        break;\n    }\n\n    var d = this.getCoords_(x + offset.x, y + offset.y);\n\n    lineStr.push('<g_vml_:line from=\"', -left ,' 0\" to=\"', right ,' 0.05\" ',\n                 ' coordsize=\"100 100\" coordorigin=\"0 0\"',\n                 ' filled=\"', !stroke, '\" stroked=\"', !!stroke,\n                 '\" style=\"position:absolute;width:1px;height:1px;\">');\n\n    if (stroke) {\n      appendStroke(this, lineStr);\n    } else {\n      \/\/ TODO: Fix the min and max params.\n      appendFill(this, lineStr, {x: -left, y: 0},\n                 {x: right, y: fontStyle.size});\n    }\n\n    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +\n                m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';\n\n    var skewOffset = mr(d.x \/ Z) + ',' + mr(d.y \/ Z);\n\n    lineStr.push('<g_vml_:skew on=\"t\" matrix=\"', skewM ,'\" ',\n                 ' offset=\"', skewOffset, '\" origin=\"', left ,' 0\" \/>',\n                 '<g_vml_:path textpathok=\"true\" \/>',\n                 '<g_vml_:textpath on=\"true\" string=\"',\n                 encodeHtmlAttribute(text),\n                 '\" style=\"v-text-align:', textAlign,\n                 ';font:', encodeHtmlAttribute(fontStyleString),\n                 '\" \/><\/g_vml_:line>');\n\n    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\n  };\n\n  contextPrototype.fillText = function(text, x, y, maxWidth) {\n    this.drawText_(text, x, y, maxWidth, false);\n  };\n\n  contextPrototype.strokeText = function(text, x, y, maxWidth) {\n    this.drawText_(text, x, y, maxWidth, true);\n  };\n\n  contextPrototype.measureText = function(text) {\n    if (!this.textMeasureEl_) {\n      var s = '<span style=\"position:absolute;' +\n          'top:-20000px;left:0;padding:0;margin:0;border:none;' +\n          'white-space:pre;\"><\/span>';\n      this.element_.insertAdjacentHTML('beforeEnd', s);\n      this.textMeasureEl_ = this.element_.lastChild;\n    }\n    var doc = this.element_.ownerDocument;\n    this.textMeasureEl_.innerHTML = '';\n    this.textMeasureEl_.style.font = this.font;\n    \/\/ Don't use innerHTML or innerText because they allow markup\/whitespace.\n    this.textMeasureEl_.appendChild(doc.createTextNode(text));\n    return {width: this.textMeasureEl_.offsetWidth};\n  };\n\n  \/******** STUBS ********\/\n  contextPrototype.clip = function() {\n    \/\/ TODO: Implement\n  };\n\n  contextPrototype.arcTo = function() {\n    \/\/ TODO: Implement\n  };\n\n  contextPrototype.createPattern = function(image, repetition) {\n    return new CanvasPattern_(image, repetition);\n  };\n\n  \/\/ Gradient \/ Pattern Stubs\n  function CanvasGradient_(aType) {\n    this.type_ = aType;\n    this.x0_ = 0;\n    this.y0_ = 0;\n    this.r0_ = 0;\n    this.x1_ = 0;\n    this.y1_ = 0;\n    this.r1_ = 0;\n    this.colors_ = [];\n  }\n\n  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {\n    aColor = processStyle(aColor);\n    this.colors_.push({offset: aOffset,\n                       color: aColor.color,\n                       alpha: aColor.alpha});\n  };\n\n  function CanvasPattern_(image, repetition) {\n    assertImageIsValid(image);\n    switch (repetition) {\n      case 'repeat':\n      case null:\n      case '':\n        this.repetition_ = 'repeat';\n        break\n      case 'repeat-x':\n      case 'repeat-y':\n      case 'no-repeat':\n        this.repetition_ = repetition;\n        break;\n      default:\n        throwException('SYNTAX_ERR');\n    }\n\n    this.src_ = image.src;\n    this.width_ = image.width;\n    this.height_ = image.height;\n  }\n\n  function throwException(s) {\n    throw new DOMException_(s);\n  }\n\n  function assertImageIsValid(img) {\n    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {\n      throwException('TYPE_MISMATCH_ERR');\n    }\n    if (img.readyState != 'complete') {\n      throwException('INVALID_STATE_ERR');\n    }\n  }\n\n  function DOMException_(s) {\n    this.code = this[s];\n    this.message = s +': DOM Exception ' + this.code;\n  }\n  var p = DOMException_.prototype = new Error;\n  p.INDEX_SIZE_ERR = 1;\n  p.DOMSTRING_SIZE_ERR = 2;\n  p.HIERARCHY_REQUEST_ERR = 3;\n  p.WRONG_DOCUMENT_ERR = 4;\n  p.INVALID_CHARACTER_ERR = 5;\n  p.NO_DATA_ALLOWED_ERR = 6;\n  p.NO_MODIFICATION_ALLOWED_ERR = 7;\n  p.NOT_FOUND_ERR = 8;\n  p.NOT_SUPPORTED_ERR = 9;\n  p.INUSE_ATTRIBUTE_ERR = 10;\n  p.INVALID_STATE_ERR = 11;\n  p.SYNTAX_ERR = 12;\n  p.INVALID_MODIFICATION_ERR = 13;\n  p.NAMESPACE_ERR = 14;\n  p.INVALID_ACCESS_ERR = 15;\n  p.VALIDATION_ERR = 16;\n  p.TYPE_MISMATCH_ERR = 17;\n\n  \/\/ set up externs\n  G_vmlCanvasManager = G_vmlCanvasManager_;\n  CanvasRenderingContext2D = CanvasRenderingContext2D_;\n  CanvasGradient = CanvasGradient_;\n  CanvasPattern = CanvasPattern_;\n  DOMException = DOMException_;\n})();\n\n} \/\/ if\n","_u":"js\/flot\/excanvas.js"}