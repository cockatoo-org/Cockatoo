{"etag":"b331664-b25-8406b530","type":"text\/plain","exp":"86400","desc":null,"data":"Flot Reference\n--------------\n\nConsider a call to the plot function:\n\n   var plot = $.plot(placeholder, data, options)\n\nThe placeholder is a jQuery object or DOM element or jQuery expression\nthat the plot will be put into. This placeholder needs to have its\nwidth and height set as explained in the README (go read that now if\nyou haven't, it's short). The plot will modify some properties of the\nplaceholder so it's recommended you simply pass in a div that you\ndon't use for anything else. Make sure you check any fancy styling\nyou apply to the div, e.g. background images have been reported to be a\nproblem on IE 7.\n\nThe format of the data is documented below, as is the available\noptions. The plot object returned from the call has some methods you\ncan call. These are documented separately below.\n\nNote that in general Flot gives no guarantees if you change any of the\nobjects you pass in to the plot function or get out of it since\nthey're not necessarily deep-copied.\n\n\nData Format\n-----------\n\nThe data is an array of data series:\n\n  [ series1, series2, ... ]\n\nA series can either be raw data or an object with properties. The raw\ndata format is an array of points:\n\n  [ [x1, y1], [x2, y2], ... ]\n\nE.g.\n\n  [ [1, 3], [2, 14.01], [3.5, 3.14] ]\n\nNote that to simplify the internal logic in Flot both the x and y\nvalues must be numbers (even if specifying time series, see below for\nhow to do this). This is a common problem because you might retrieve\ndata from the database and serialize them directly to JSON without\nnoticing the wrong type. If you're getting mysterious errors, double\ncheck that you're inputting numbers and not strings.\n\nIf a null is specified as a point or if one of the coordinates is null\nor couldn't be converted to a number, the point is ignored when\ndrawing. As a special case, a null value for lines is interpreted as a\nline segment end, i.e. the points before and after the null value are\nnot connected.\n\nLines and points take two coordinates. For filled lines and bars, you\ncan specify a third coordinate which is the bottom of the filled\narea\/bar (defaults to 0).\n\nThe format of a single series object is as follows:\n\n  {\n    color: color or number\n    data: rawdata\n    label: string\n    lines: specific lines options\n    bars: specific bars options\n    points: specific points options\n    xaxis: number\n    yaxis: number\n    clickable: boolean\n    hoverable: boolean\n    shadowSize: number\n  }\n\nYou don't have to specify any of them except the data, the rest are\noptions that will get default values. Typically you'd only specify\nlabel and data, like this:\n\n  {\n    label: \"y = 3\",\n    data: [[0, 3], [10, 3]]\n  }\n\nThe label is used for the legend, if you don't specify one, the series\nwill not show up in the legend.\n\nIf you don't specify color, the series will get a color from the\nauto-generated colors. The color is either a CSS color specification\n(like \"rgb(255, 100, 123)\") or an integer that specifies which of\nauto-generated colors to select, e.g. 0 will get color no. 0, etc.\n\nThe latter is mostly useful if you let the user add and remove series,\nin which case you can hard-code the color index to prevent the colors\nfrom jumping around between the series.\n\nThe \"xaxis\" and \"yaxis\" options specify which axis to use. The axes\nare numbered from 1 (default), so { yaxis: 2} means that the series\nshould be plotted against the second y axis.\n\n\"clickable\" and \"hoverable\" can be set to false to disable\ninteractivity for specific series if interactivity is turned on in\nthe plot, see below.\n\nThe rest of the options are all documented below as they are the same\nas the default options passed in via the options parameter in the plot\ncommmand. When you specify them for a specific data series, they will\noverride the default options for the plot for that data series.\n\nHere's a complete example of a simple data specification:\n\n  [ { label: \"Foo\", data: [ [10, 1], [17, -14], [30, 5] ] },\n    { label: \"Bar\", data: [ [11, 13], [19, 11], [30, -7] ] } ]\n\n\nPlot Options\n------------\n\nAll options are completely optional. They are documented individually\nbelow, to change them you just specify them in an object, e.g.\n\n  var options = {\n    series: {\n      lines: { show: true },\n      points: { show: true }\n    }\n  };\n\n  $.plot(placeholder, data, options);\n\n\nCustomizing the legend\n======================\n\n  legend: {\n    show: boolean\n    labelFormatter: null or (fn: string, series object -> string)\n    labelBoxBorderColor: color\n    noColumns: number\n    position: \"ne\" or \"nw\" or \"se\" or \"sw\"\n    margin: number of pixels or [x margin, y margin]\n    backgroundColor: null or color\n    backgroundOpacity: number between 0 and 1\n    container: null or jQuery object\/DOM element\/jQuery expression\n  }\n\nThe legend is generated as a table with the data series labels and\nsmall label boxes with the color of the series. If you want to format\nthe labels in some way, e.g. make them to links, you can pass in a\nfunction for \"labelFormatter\". Here's an example that makes them\nclickable:\n\n  labelFormatter: function(label, series) {\n    \/\/ series is the series object for the label\n    return '<a href=\"#' + label + '\">' + label + '<\/a>';\n  }\n\n\"noColumns\" is the number of columns to divide the legend table into.\n\"position\" specifies the overall placement of the legend within the\nplot (top-right, top-left, etc.) and margin the distance to the plot\nedge (this can be either a number or an array of two numbers like [x,\ny]). \"backgroundColor\" and \"backgroundOpacity\" specifies the\nbackground. The default is a partly transparent auto-detected\nbackground.\n\nIf you want the legend to appear somewhere else in the DOM, you can\nspecify \"container\" as a jQuery object\/expression to put the legend\ntable into. The \"position\" and \"margin\" etc. options will then be\nignored. Note that Flot will overwrite the contents of the container.\n\n\nCustomizing the axes\n====================\n\n  xaxis, yaxis: {\n    show: null or true\/false\n    position: \"bottom\" or \"top\" or \"left\" or \"right\"\n    mode: null or \"time\"\n\n    color: null or color spec\n    tickColor: null or color spec\n    \n    min: null or number\n    max: null or number\n    autoscaleMargin: null or number\n    \n    transform: null or fn: number -> number\n    inverseTransform: null or fn: number -> number\n    \n    ticks: null or number or ticks array or (fn: range -> ticks array)\n    tickSize: number or array\n    minTickSize: number or array\n    tickFormatter: (fn: number, object -> string) or string\n    tickDecimals: null or number\n\n    labelWidth: null or number\n    labelHeight: null or number\n    reserveSpace: null or true\n    \n    tickLength: null or number\n\n    alignTicksWithAxis: null or number\n  }\n\nAll axes have the same kind of options. The following describes how to\nconfigure one axis, see below for what to do if you've got more than\none x axis or y axis.\n\nIf you don't set the \"show\" option (i.e. it is null), visibility is\nauto-detected, i.e. the axis will show up if there's data associated\nwith it. You can override this by setting the \"show\" option to true or\nfalse.\n\nThe \"position\" option specifies where the axis is placed, bottom or\ntop for x axes, left or right for y axes. The \"mode\" option determines\nhow the data is interpreted, the default of null means as decimal\nnumbers. Use \"time\" for time series data, see the time series data\nsection.\n\nThe \"color\" option determines the color of the labels and ticks for\nthe axis (default is the grid color). For more fine-grained control\nyou can also set the color of the ticks separately with \"tickColor\"\n(otherwise it's autogenerated as the base color with some\ntransparency).\n\nThe options \"min\"\/\"max\" are the precise minimum\/maximum value on the\nscale. If you don't specify either of them, a value will automatically\nbe chosen based on the minimum\/maximum data values. Note that Flot\nalways examines all the data values you feed to it, even if a\nrestriction on another axis may make some of them invisible (this\nmakes interactive use more stable).\n\nThe \"autoscaleMargin\" is a bit esoteric: it's the fraction of margin\nthat the scaling algorithm will add to avoid that the outermost points\nends up on the grid border. Note that this margin is only applied when\na min or max value is not explicitly set. If a margin is specified,\nthe plot will furthermore extend the axis end-point to the nearest\nwhole tick. The default value is \"null\" for the x axes and 0.02 for y\naxes which seems appropriate for most cases.\n\n\"transform\" and \"inverseTransform\" are callbacks you can put in to\nchange the way the data is drawn. You can design a function to\ncompress or expand certain parts of the axis non-linearly, e.g.\nsuppress weekends or compress far away points with a logarithm or some\nother means. When Flot draws the plot, each value is first put through\nthe transform function. Here's an example, the x axis can be turned\ninto a natural logarithm axis with the following code:\n\n  xaxis: {\n    transform: function (v) { return Math.log(v); },\n    inverseTransform: function (v) { return Math.exp(v); }\n  }\n\nSimilarly, for reversing the y axis so the values appear in inverse\norder:\n  \n  yaxis: {\n    transform: function (v) { return -v; },\n    inverseTransform: function (v) { return -v; }\n  }\n\nNote that for finding extrema, Flot assumes that the transform\nfunction does not reorder values (it should be monotone).\n\nThe inverseTransform is simply the inverse of the transform function\n(so v == inverseTransform(transform(v)) for all relevant v). It is\nrequired for converting from canvas coordinates to data coordinates,\ne.g. for a mouse interaction where a certain pixel is clicked. If you\ndon't use any interactive features of Flot, you may not need it.\n\n\nThe rest of the options deal with the ticks.\n\nIf you don't specify any ticks, a tick generator algorithm will make\nsome for you. The algorithm has two passes. It first estimates how\nmany ticks would be reasonable and uses this number to compute a nice\nround tick interval size. Then it generates the ticks.\n\nYou can specify how many ticks the algorithm aims for by setting\n\"ticks\" to a number. The algorithm always tries to generate reasonably\nround tick values so even if you ask for three ticks, you might get\nfive if that fits better with the rounding. If you don't want any\nticks at all, set \"ticks\" to 0 or an empty array.\n\nAnother option is to skip the rounding part and directly set the tick\ninterval size with \"tickSize\". If you set it to 2, you'll get ticks at\n2, 4, 6, etc. Alternatively, you can specify that you just don't want\nticks at a size less than a specific tick size with \"minTickSize\".\nNote that for time series, the format is an array like [2, \"month\"],\nsee the next section.\n\nIf you want to completely override the tick algorithm, you can specify\nan array for \"ticks\", either like this:\n\n  ticks: [0, 1.2, 2.4]\n\nOr like this where the labels are also customized:\n\n  ticks: [[0, \"zero\"], [1.2, \"one mark\"], [2.4, \"two marks\"]]\n\nYou can mix the two if you like.\n  \nFor extra flexibility you can specify a function as the \"ticks\"\nparameter. The function will be called with an object with the axis\nmin and max and should return a ticks array. Here's a simplistic tick\ngenerator that spits out intervals of pi, suitable for use on the x\naxis for trigonometric functions:\n\n  function piTickGenerator(axis) {\n    var res = [], i = Math.floor(axis.min \/ Math.PI);\n    do {\n      var v = i * Math.PI;\n      res.push([v, i + \"\\u03c0\"]);\n      ++i;\n    } while (v < axis.max);\n    \n    return res;\n  }\n\nYou can control how the ticks look like with \"tickDecimals\", the\nnumber of decimals to display (default is auto-detected).\n\nAlternatively, for ultimate control over how ticks are formatted you can\nprovide a function to \"tickFormatter\". The function is passed two\nparameters, the tick value and an axis object with information, and\nshould return a string. The default formatter looks like this:\n\n  function formatter(val, axis) {\n    return val.toFixed(axis.tickDecimals);\n  }\n\nThe axis object has \"min\" and \"max\" with the range of the axis,\n\"tickDecimals\" with the number of decimals to round the value to and\n\"tickSize\" with the size of the interval between ticks as calculated\nby the automatic axis scaling algorithm (or specified by you). Here's\nan example of a custom formatter:\n\n  function suffixFormatter(val, axis) {\n    if (val > 1000000)\n      return (val \/ 1000000).toFixed(axis.tickDecimals) + \" MB\";\n    else if (val > 1000)\n      return (val \/ 1000).toFixed(axis.tickDecimals) + \" kB\";\n    else\n      return val.toFixed(axis.tickDecimals) + \" B\";\n  }\n\n\"labelWidth\" and \"labelHeight\" specifies a fixed size of the tick\nlabels in pixels. They're useful in case you need to align several\nplots. \"reserveSpace\" means that even if an axis isn't shown, Flot\nshould reserve space for it - it is useful in combination with\nlabelWidth and labelHeight for aligning multi-axis charts.\n\n\"tickLength\" is the length of the tick lines in pixels. By default, the\ninnermost axes will have ticks that extend all across the plot, while\nany extra axes use small ticks. A value of null means use the default,\nwhile a number means small ticks of that length - set it to 0 to hide\nthe lines completely.\n\nIf you set \"alignTicksWithAxis\" to the number of another axis, e.g.\nalignTicksWithAxis: 1, Flot will ensure that the autogenerated ticks\nof this axis are aligned with the ticks of the other axis. This may\nimprove the looks, e.g. if you have one y axis to the left and one to\nthe right, because the grid lines will then match the ticks in both\nends. The trade-off is that the forced ticks won't necessarily be at\nnatural places.\n\n\nMultiple axes\n=============\n\nIf you need more than one x axis or y axis, you need to specify for\neach data series which axis they are to use, as described under the\nformat of the data series, e.g. { data: [...], yaxis: 2 } specifies\nthat a series should be plotted against the second y axis.\n\nTo actually configure that axis, you can't use the xaxis\/yaxis options\ndirectly - instead there are two arrays in the options:\n\n   xaxes: []\n   yaxes: []\n\nHere's an example of configuring a single x axis and two y axes (we\ncan leave options of the first y axis empty as the defaults are fine):\n\n  {\n    xaxes: [ { position: \"top\" } ],\n    yaxes: [ { }, { position: \"right\", min: 20 } ]\n  }\n\nThe arrays get their default values from the xaxis\/yaxis settings, so\nsay you want to have all y axes start at zero, you can simply specify\nyaxis: { min: 0 } instead of adding a min parameter to all the axes.\n\nGenerally, the various interfaces in Flot dealing with data points\neither accept an xaxis\/yaxis parameter to specify which axis number to\nuse (starting from 1), or lets you specify the coordinate directly as\nx2\/x3\/... or x2axis\/x3axis\/... instead of \"x\" or \"xaxis\".\n\n  \nTime series data\n================\n\nTime series are a bit more difficult than scalar data because\ncalendars don't follow a simple base 10 system. For many cases, Flot\nabstracts most of this away, but it can still be a bit difficult to\nget the data into Flot. So we'll first discuss the data format.\n\nThe time series support in Flot is based on Javascript timestamps,\ni.e. everywhere a time value is expected or handed over, a Javascript\ntimestamp number is used. This is a number, not a Date object. A\nJavascript timestamp is the number of milliseconds since January 1,\n1970 00:00:00 UTC. This is almost the same as Unix timestamps, except it's\nin milliseconds, so remember to multiply by 1000!\n\nYou can see a timestamp like this\n\n  alert((new Date()).getTime())\n\nNormally you want the timestamps to be displayed according to a\ncertain time zone, usually the time zone in which the data has been\nproduced. However, Flot always displays timestamps according to UTC.\nIt has to as the only alternative with core Javascript is to interpret\nthe timestamps according to the time zone that the visitor is in,\nwhich means that the ticks will shift unpredictably with the time zone\nand daylight savings of each visitor.\n\nSo given that there's no good support for custom time zones in\nJavascript, you'll have to take care of this server-side.\n\nThe easiest way to think about it is to pretend that the data\nproduction time zone is UTC, even if it isn't. So if you have a\ndatapoint at 2002-02-20 08:00, you can generate a timestamp for eight\no'clock UTC even if it really happened eight o'clock UTC+0200.\n\nIn PHP you can get an appropriate timestamp with\n'strtotime(\"2002-02-20 UTC\") * 1000', in Python with\n'calendar.timegm(datetime_object.timetuple()) * 1000', in .NET with\nsomething like:\n\n  public static int GetJavascriptTimestamp(System.DateTime input)\n  {\n    System.TimeSpan span = new System.TimeSpan(System.DateTime.Parse(\"1\/1\/1970\").Ticks);\n    System.DateTime time = input.Subtract(span);\n    return (long)(time.Ticks \/ 10000);\n  }\n\nJavascript also has some support for parsing date strings, so it is\npossible to generate the timestamps manually client-side.\n\nIf you've already got the real UTC timestamp, it's too late to use the\npretend trick described above. But you can fix up the timestamps by\nadding the time zone offset, e.g. for UTC+0200 you would add 2 hours\nto the UTC timestamp you got. Then it'll look right on the plot. Most\nprogramming environments have some means of getting the timezone\noffset for a specific date (note that you need to get the offset for\neach individual timestamp to account for daylight savings).\n\nOnce you've gotten the timestamps into the data and specified \"time\"\nas the axis mode, Flot will automatically generate relevant ticks and\nformat them. As always, you can tweak the ticks via the \"ticks\" option\n- just remember that the values should be timestamps (numbers), not\nDate objects.\n\nTick generation and formatting can also be controlled separately\nthrough the following axis options:\n\n  minTickSize: array\n  timeformat: null or format string\n  monthNames: null or array of size 12 of strings\n  twelveHourClock: boolean\n\nHere \"timeformat\" is a format string to use. You might use it like\nthis:\n\n  xaxis: {\n    mode: \"time\"\n    timeformat: \"%y\/%m\/%d\"\n  }\n  \nThis will result in tick labels like \"2000\/12\/24\". The following\nspecifiers are supported\n\n  %h: hours\n  %H: hours (left-padded with a zero)\n  %M: minutes (left-padded with a zero)\n  %S: seconds (left-padded with a zero)\n  %d: day of month (1-31), use %0d for zero-padding\n  %m: month (1-12), use %0m for zero-padding\n  %y: year (four digits)\n  %b: month name (customizable)\n  %p: am\/pm, additionally switches %h\/%H to 12 hour instead of 24\n  %P: AM\/PM (uppercase version of %p)\n\nInserting a zero like %0m or %0d means that the specifier will be\nleft-padded with a zero if it's only single-digit. So %y-%0m-%0d\nresults in unambigious ISO timestamps like 2007-05-10 (for May 10th).\n\nYou can customize the month names with the \"monthNames\" option. For\ninstance, for Danish you might specify:\n\n  monthNames: [\"jan\", \"feb\", \"mar\", \"apr\", \"maj\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n\nIf you set \"twelveHourClock\" to true, the autogenerated timestamps\nwill use 12 hour AM\/PM timestamps instead of 24 hour.\n  \nThe format string and month names are used by a very simple built-in\nformat function that takes a date object, a format string (and\noptionally an array of month names) and returns the formatted string.\nIf needed, you can access it as $.plot.formatDate(date, formatstring,\nmonthNames) or even replace it with another more advanced function\nfrom a date library if you're feeling adventurous.\n\nIf everything else fails, you can control the formatting by specifying\na custom tick formatter function as usual. Here's a simple example\nwhich will format December 24 as 24\/12:\n\n  tickFormatter: function (val, axis) {\n    var d = new Date(val);\n    return d.getUTCDate() + \"\/\" + (d.getUTCMonth() + 1);\n  }\n\nNote that for the time mode \"tickSize\" and \"minTickSize\" are a bit\nspecial in that they are arrays on the form \"[value, unit]\" where unit\nis one of \"second\", \"minute\", \"hour\", \"day\", \"month\" and \"year\". So\nyou can specify\n\n  minTickSize: [1, \"month\"]\n\nto get a tick interval size of at least 1 month and correspondingly,\nif axis.tickSize is [2, \"day\"] in the tick formatter, the ticks have\nbeen produced with two days in-between.\n\n\n\nCustomizing the data series\n===========================\n\n  series: {\n    lines, points, bars: {\n      show: boolean\n      lineWidth: number\n      fill: boolean or number\n      fillColor: null or color\/gradient\n    }\n\n    points: {\n      radius: number\n      symbol: \"circle\" or function\n    }\n\n    bars: {\n      barWidth: number\n      align: \"left\" or \"center\"\n      horizontal: boolean\n    }\n\n    lines: {\n      steps: boolean\n    }\n\n    shadowSize: number\n  }\n  \n  colors: [ color1, color2, ... ]\n\nThe options inside \"series: {}\" are copied to each of the series. So\nyou can specify that all series should have bars by putting it in the\nglobal options, or override it for individual series by specifying\nbars in a particular the series object in the array of data.\n  \nThe most important options are \"lines\", \"points\" and \"bars\" that\nspecify whether and how lines, points and bars should be shown for\neach data series. In case you don't specify anything at all, Flot will\ndefault to showing lines (you can turn this off with\nlines: { show: false }). You can specify the various types\nindependently of each other, and Flot will happily draw each of them\nin turn (this is probably only useful for lines and points), e.g.\n\n  var options = {\n    series: {\n      lines: { show: true, fill: true, fillColor: \"rgba(255, 255, 255, 0.8)\" },\n      points: { show: true, fill: false }\n    }\n  };\n\n\"lineWidth\" is the thickness of the line or outline in pixels. You can\nset it to 0 to prevent a line or outline from being drawn; this will\nalso hide the shadow.\n\n\"fill\" is whether the shape should be filled. For lines, this produces\narea graphs. You can use \"fillColor\" to specify the color of the fill.\nIf \"fillColor\" evaluates to false (default for everything except\npoints which are filled with white), the fill color is auto-set to the\ncolor of the data series. You can adjust the opacity of the fill by\nsetting fill to a number between 0 (fully transparent) and 1 (fully\nopaque).\n\nFor bars, fillColor can be a gradient, see the gradient documentation\nbelow. \"barWidth\" is the width of the bars in units of the x axis (or\nthe y axis if \"horizontal\" is true), contrary to most other measures\nthat are specified in pixels. For instance, for time series the unit\nis milliseconds so 24 * 60 * 60 * 1000 produces bars with the width of\na day. \"align\" specifies whether a bar should be left-aligned\n(default) or centered on top of the value it represents. When\n\"horizontal\" is on, the bars are drawn horizontally, i.e. from the y\naxis instead of the x axis; note that the bar end points are still\ndefined in the same way so you'll probably want to swap the\ncoordinates if you've been plotting vertical bars first.\n\nFor lines, \"steps\" specifies whether two adjacent data points are\nconnected with a straight (possibly diagonal) line or with first a\nhorizontal and then a vertical line. Note that this transforms the\ndata by adding extra points.\n\nFor points, you can specify the radius and the symbol. The only\nbuilt-in symbol type is circles, for other types you can use a plugin\nor define them yourself by specifying a callback:\n\n  function cross(ctx, x, y, radius, shadow) {\n      var size = radius * Math.sqrt(Math.PI) \/ 2;\n      ctx.moveTo(x - size, y - size);\n      ctx.lineTo(x + size, y + size);\n      ctx.moveTo(x - size, y + size);\n      ctx.lineTo(x + size, y - size);\n  }\n\nThe parameters are the drawing context, x and y coordinates of the\ncenter of the point, a radius which corresponds to what the circle\nwould have used and whether the call is to draw a shadow (due to\nlimited canvas support, shadows are currently faked through extra\ndraws). It's good practice to ensure that the area covered by the\nsymbol is the same as for the circle with the given radius, this\nensures that all symbols have approximately the same visual weight.\n\n\"shadowSize\" is the default size of shadows in pixels. Set it to 0 to\nremove shadows.\n\nThe \"colors\" array specifies a default color theme to get colors for\nthe data series from. You can specify as many colors as you like, like\nthis:\n\n  colors: [\"#d18b2c\", \"#dba255\", \"#919733\"]\n\nIf there are more data series than colors, Flot will try to generate\nextra colors by lightening and darkening colors in the theme.\n\n\nCustomizing the grid\n====================\n\n  grid: {\n    show: boolean\n    aboveData: boolean\n    color: color\n    backgroundColor: color\/gradient or null\n    labelMargin: number\n    axisMargin: number\n    markings: array of markings or (fn: axes -> array of markings)\n    borderWidth: number\n    borderColor: color or null\n    minBorderMargin: number or null\n    clickable: boolean\n    hoverable: boolean\n    autoHighlight: boolean\n    mouseActiveRadius: number\n  }\n\nThe grid is the thing with the axes and a number of ticks. Many of the\nthings in the grid are configured under the individual axes, but not\nall. \"color\" is the color of the grid itself whereas \"backgroundColor\"\nspecifies the background color inside the grid area, here null means\nthat the background is transparent. You can also set a gradient, see\nthe gradient documentation below.\n\nYou can turn off the whole grid including tick labels by setting\n\"show\" to false. \"aboveData\" determines whether the grid is drawn\nabove the data or below (below is default).\n\n\"labelMargin\" is the space in pixels between tick labels and axis\nline, and \"axisMargin\" is the space in pixels between axes when there\nare two next to each other. Note that you can style the tick labels\nwith CSS, e.g. to change the color. They have class \"tickLabel\".\n\n\"borderWidth\" is the width of the border around the plot. Set it to 0\nto disable the border. You can also set \"borderColor\" if you want the\nborder to have a different color than the grid lines.\n\"minBorderMargin\" controls the default minimum margin around the\nborder - it's used to make sure that points aren't accidentally\nclipped by the canvas edge so by default the value is computed from\nthe point radius.\n\n\"markings\" is used to draw simple lines and rectangular areas in the\nbackground of the plot. You can either specify an array of ranges on\nthe form { xaxis: { from, to }, yaxis: { from, to } } (with multiple\naxes, you can specify coordinates for other axes instead, e.g. as\nx2axis\/x3axis\/...) or with a function that returns such an array given\nthe axes for the plot in an object as the first parameter.\n\nYou can set the color of markings by specifying \"color\" in the ranges\nobject. Here's an example array:\n\n  markings: [ { xaxis: { from: 0, to: 2 }, yaxis: { from: 10, to: 10 }, color: \"#bb0000\" }, ... ]\n\nIf you leave out one of the values, that value is assumed to go to the\nborder of the plot. So for example if you only specify { xaxis: {\nfrom: 0, to: 2 } } it means an area that extends from the top to the\nbottom of the plot in the x range 0-2.\n\nA line is drawn if from and to are the same, e.g.\n\n  markings: [ { yaxis: { from: 1, to: 1 } }, ... ]\n\nwould draw a line parallel to the x axis at y = 1. You can control the\nline width with \"lineWidth\" in the range object.\n\nAn example function that makes vertical stripes might look like this:\n\n  markings: function (axes) {\n    var markings = [];\n    for (var x = Math.floor(axes.xaxis.min); x < axes.xaxis.max; x += 2)\n      markings.push({ xaxis: { from: x, to: x + 1 } });\n    return markings;\n  }\n\n\nIf you set \"clickable\" to true, the plot will listen for click events\non the plot area and fire a \"plotclick\" event on the placeholder with\na position and a nearby data item object as parameters. The coordinates\nare available both in the unit of the axes (not in pixels) and in\nglobal screen coordinates.\n\nLikewise, if you set \"hoverable\" to true, the plot will listen for\nmouse move events on the plot area and fire a \"plothover\" event with\nthe same parameters as the \"plotclick\" event. If \"autoHighlight\" is\ntrue (the default), nearby data items are highlighted automatically.\nIf needed, you can disable highlighting and control it yourself with\nthe highlight\/unhighlight plot methods described elsewhere.\n\nYou can use \"plotclick\" and \"plothover\" events like this:\n\n    $.plot($(\"#placeholder\"), [ d ], { grid: { clickable: true } });\n\n    $(\"#placeholder\").bind(\"plotclick\", function (event, pos, item) {\n        alert(\"You clicked at \" + pos.x + \", \" + pos.y);\n        \/\/ axis coordinates for other axes, if present, are in pos.x2, pos.x3, ...\n        \/\/ if you need global screen coordinates, they are pos.pageX, pos.pageY\n\n        if (item) {\n          highlight(item.series, item.datapoint);\n          alert(\"You clicked a point!\");\n        }\n    });\n\nThe item object in this example is either null or a nearby object on the form:\n\n  item: {\n      datapoint: the point, e.g. [0, 2]\n      dataIndex: the index of the point in the data array\n      series: the series object\n      seriesIndex: the index of the series\n      pageX, pageY: the global screen coordinates of the point\n  }\n\nFor instance, if you have specified the data like this \n\n    $.plot($(\"#placeholder\"), [ { label: \"Foo\", data: [[0, 10], [7, 3]] } ], ...);\n\nand the mouse is near the point (7, 3), \"datapoint\" is [7, 3],\n\"dataIndex\" will be 1, \"series\" is a normalized series object with\namong other things the \"Foo\" label in series.label and the color in\nseries.color, and \"seriesIndex\" is 0. Note that plugins and options\nthat transform the data can shift the indexes from what you specified\nin the original data array.\n\nIf you use the above events to update some other information and want\nto clear out that info in case the mouse goes away, you'll probably\nalso need to listen to \"mouseout\" events on the placeholder div.\n\n\"mouseActiveRadius\" specifies how far the mouse can be from an item\nand still activate it. If there are two or more points within this\nradius, Flot chooses the closest item. For bars, the top-most bar\n(from the latest specified data series) is chosen.\n\nIf you want to disable interactivity for a specific data series, you\ncan set \"hoverable\" and \"clickable\" to false in the options for that\nseries, like this { data: [...], label: \"Foo\", clickable: false }.\n\n\nSpecifying gradients\n====================\n\nA gradient is specified like this:\n\n  { colors: [ color1, color2, ... ] }\n\nFor instance, you might specify a background on the grid going from\nblack to gray like this:\n\n  grid: {\n    backgroundColor: { colors: [\"#000\", \"#999\"] }\n  }\n\nFor the series you can specify the gradient as an object that\nspecifies the scaling of the brightness and the opacity of the series\ncolor, e.g.\n\n  { colors: [{ opacity: 0.8 }, { brightness: 0.6, opacity: 0.8 } ] }\n\nwhere the first color simply has its alpha scaled, whereas the second\nis also darkened. For instance, for bars the following makes the bars\ngradually disappear, without outline:\n\n  bars: {\n      show: true,\n      lineWidth: 0,\n      fill: true,\n      fillColor: { colors: [ { opacity: 0.8 }, { opacity: 0.1 } ] }\n  }\n  \nFlot currently only supports vertical gradients drawn from top to\nbottom because that's what works with IE.\n\n\nPlot Methods\n------------\n\nThe Plot object returned from the plot function has some methods you\ncan call:\n\n  - highlight(series, datapoint)\n\n    Highlight a specific datapoint in the data series. You can either\n    specify the actual objects, e.g. if you got them from a\n    \"plotclick\" event, or you can specify the indices, e.g.\n    highlight(1, 3) to highlight the fourth point in the second series\n    (remember, zero-based indexing).\n\n  \n  - unhighlight(series, datapoint) or unhighlight()\n\n    Remove the highlighting of the point, same parameters as\n    highlight.\n\n    If you call unhighlight with no parameters, e.g. as\n    plot.unhighlight(), all current highlights are removed.\n\n\n  - setData(data)\n\n    You can use this to reset the data used. Note that axis scaling,\n    ticks, legend etc. will not be recomputed (use setupGrid() to do\n    that). You'll probably want to call draw() afterwards.\n\n    You can use this function to speed up redrawing a small plot if\n    you know that the axes won't change. Put in the new data with\n    setData(newdata), call draw(), and you're good to go. Note that\n    for large datasets, almost all the time is consumed in draw()\n    plotting the data so in this case don't bother.\n\n    \n  - setupGrid()\n\n    Recalculate and set axis scaling, ticks, legend etc.\n\n    Note that because of the drawing model of the canvas, this\n    function will immediately redraw (actually reinsert in the DOM)\n    the labels and the legend, but not the actual tick lines because\n    they're drawn on the canvas. You need to call draw() to get the\n    canvas redrawn.\n    \n  - draw()\n\n    Redraws the plot canvas.\n\n  - triggerRedrawOverlay()\n\n    Schedules an update of an overlay canvas used for drawing\n    interactive things like a selection and point highlights. This\n    is mostly useful for writing plugins. The redraw doesn't happen\n    immediately, instead a timer is set to catch multiple successive\n    redraws (e.g. from a mousemove). You can get to the overlay by\n    setting up a drawOverlay hook.\n\n  - width()\/height()\n\n    Gets the width and height of the plotting area inside the grid.\n    This is smaller than the canvas or placeholder dimensions as some\n    extra space is needed (e.g. for labels).\n\n  - offset()\n\n    Returns the offset of the plotting area inside the grid relative\n    to the document, useful for instance for calculating mouse\n    positions (event.pageX\/Y minus this offset is the pixel position\n    inside the plot).\n\n  - pointOffset({ x: xpos, y: ypos })\n\n    Returns the calculated offset of the data point at (x, y) in data\n    space within the placeholder div. If you are working with multiple axes, you\n    can specify the x and y axis references, e.g. \n\n      o = pointOffset({ x: xpos, y: ypos, xaxis: 2, yaxis: 3 })\n      \/\/ o.left and o.top now contains the offset within the div\n\n  - resize()\n\n    Tells Flot to resize the drawing canvas to the size of the\n    placeholder. You need to run setupGrid() and draw() afterwards as\n    canvas resizing is a destructive operation. This is used\n    internally by the resize plugin.\n\n  - shutdown()\n\n    Cleans up any event handlers Flot has currently registered. This\n    is used internally.\n\n\nThere are also some members that let you peek inside the internal\nworkings of Flot which is useful in some cases. Note that if you change\nsomething in the objects returned, you're changing the objects used by\nFlot to keep track of its state, so be careful.\n\n  - getData()\n\n    Returns an array of the data series currently used in normalized\n    form with missing settings filled in according to the global\n    options. So for instance to find out what color Flot has assigned\n    to the data series, you could do this:\n\n      var series = plot.getData();\n      for (var i = 0; i < series.length; ++i)\n        alert(series[i].color);\n\n    A notable other interesting field besides color is datapoints\n    which has a field \"points\" with the normalized data points in a\n    flat array (the field \"pointsize\" is the increment in the flat\n    array to get to the next point so for a dataset consisting only of\n    (x,y) pairs it would be 2).\n\n  - getAxes()\n\n    Gets an object with the axes. The axes are returned as the\n    attributes of the object, so for instance getAxes().xaxis is the\n    x axis.\n\n    Various things are stuffed inside an axis object, e.g. you could\n    use getAxes().xaxis.ticks to find out what the ticks are for the\n    xaxis. Two other useful attributes are p2c and c2p, functions for\n    transforming from data point space to the canvas plot space and\n    back. Both returns values that are offset with the plot offset.\n    Check the Flot source code for the complete set of attributes (or\n    output an axis with console.log() and inspect it).\n\n    With multiple axes, the extra axes are returned as x2axis, x3axis,\n    etc., e.g. getAxes().y2axis is the second y axis. You can check\n    y2axis.used to see whether the axis is associated with any data\n    points and y2axis.show to see if it is currently shown. \n \n  - getPlaceholder()\n\n    Returns placeholder that the plot was put into. This can be useful\n    for plugins for adding DOM elements or firing events.\n\n  - getCanvas()\n\n    Returns the canvas used for drawing in case you need to hack on it\n    yourself. You'll probably need to get the plot offset too.\n  \n  - getPlotOffset()\n\n    Gets the offset that the grid has within the canvas as an object\n    with distances from the canvas edges as \"left\", \"right\", \"top\",\n    \"bottom\". I.e., if you draw a circle on the canvas with the center\n    placed at (left, top), its center will be at the top-most, left\n    corner of the grid.\n\n  - getOptions()\n\n    Gets the options for the plot, normalized, with default values\n    filled in. You get a reference to actual values used by Flot, so\n    if you modify the values in here, Flot will use the new values.\n    If you change something, you probably have to call draw() or\n    setupGrid() or triggerRedrawOverlay() to see the change.\n    \n\nHooks\n=====\n\nIn addition to the public methods, the Plot object also has some hooks\nthat can be used to modify the plotting process. You can install a\ncallback function at various points in the process, the function then\ngets access to the internal data structures in Flot.\n\nHere's an overview of the phases Flot goes through:\n\n  1. Plugin initialization, parsing options\n  \n  2. Constructing the canvases used for drawing\n\n  3. Set data: parsing data specification, calculating colors,\n     copying raw data points into internal format,\n     normalizing them, finding max\/min for axis auto-scaling\n\n  4. Grid setup: calculating axis spacing, ticks, inserting tick\n     labels, the legend\n\n  5. Draw: drawing the grid, drawing each of the series in turn\n\n  6. Setting up event handling for interactive features\n\n  7. Responding to events, if any\n\n  8. Shutdown: this mostly happens in case a plot is overwritten \n\nEach hook is simply a function which is put in the appropriate array.\nYou can add them through the \"hooks\" option, and they are also available\nafter the plot is constructed as the \"hooks\" attribute on the returned\nplot object, e.g.\n\n  \/\/ define a simple draw hook\n  function hellohook(plot, canvascontext) { alert(\"hello!\"); };\n\n  \/\/ pass it in, in an array since we might want to specify several\n  var plot = $.plot(placeholder, data, { hooks: { draw: [hellohook] } });\n\n  \/\/ we can now find it again in plot.hooks.draw[0] unless a plugin\n  \/\/ has added other hooks\n\nThe available hooks are described below. All hook callbacks get the\nplot object as first parameter. You can find some examples of defined\nhooks in the plugins bundled with Flot.\n\n - processOptions  [phase 1]\n\n   function(plot, options)\n   \n   Called after Flot has parsed and merged options. Useful in the\n   instance where customizations beyond simple merging of default\n   values is needed. A plugin might use it to detect that it has been\n   enabled and then turn on or off other options.\n\n \n - processRawData  [phase 3]\n\n   function(plot, series, data, datapoints)\n \n   Called before Flot copies and normalizes the raw data for the given\n   series. If the function fills in datapoints.points with normalized\n   points and sets datapoints.pointsize to the size of the points,\n   Flot will skip the copying\/normalization step for this series.\n   \n   In any case, you might be interested in setting datapoints.format,\n   an array of objects for specifying how a point is normalized and\n   how it interferes with axis scaling.\n\n   The default format array for points is something along the lines of:\n\n     [\n       { x: true, number: true, required: true },\n       { y: true, number: true, required: true }\n     ]\n\n   The first object means that for the first coordinate it should be\n   taken into account when scaling the x axis, that it must be a\n   number, and that it is required - so if it is null or cannot be\n   converted to a number, the whole point will be zeroed out with\n   nulls. Beyond these you can also specify \"defaultValue\", a value to\n   use if the coordinate is null. This is for instance handy for bars\n   where one can omit the third coordinate (the bottom of the bar)\n   which then defaults to 0.\n\n\n - processDatapoints  [phase 3]\n\n   function(plot, series, datapoints)\n \n   Called after normalization of the given series but before finding\n   min\/max of the data points. This hook is useful for implementing data\n   transformations. \"datapoints\" contains the normalized data points in\n   a flat array as datapoints.points with the size of a single point\n   given in datapoints.pointsize. Here's a simple transform that\n   multiplies all y coordinates by 2:\n\n     function multiply(plot, series, datapoints) {\n         var points = datapoints.points, ps = datapoints.pointsize;\n         for (var i = 0; i < points.length; i += ps)\n             points[i + 1] *= 2;\n     }\n\n   Note that you must leave datapoints in a good condition as Flot\n   doesn't check it or do any normalization on it afterwards.\n\n\n - drawSeries  [phase 5]\n\n   function(plot, canvascontext, series)\n\n   Hook for custom drawing of a single series. Called just before the\n   standard drawing routine has been called in the loop that draws\n   each series.\n   \n \n - draw  [phase 5]\n\n   function(plot, canvascontext)\n \n   Hook for drawing on the canvas. Called after the grid is drawn\n   (unless it's disabled or grid.aboveData is set) and the series have\n   been plotted (in case any points, lines or bars have been turned\n   on). For examples of how to draw things, look at the source code.\n   \n \n - bindEvents  [phase 6]\n\n   function(plot, eventHolder)\n\n   Called after Flot has setup its event handlers. Should set any\n   necessary event handlers on eventHolder, a jQuery object with the\n   canvas, e.g.\n\n     function (plot, eventHolder) {\n         eventHolder.mousedown(function (e) {\n             alert(\"You pressed the mouse at \" + e.pageX + \" \" + e.pageY);\n         });\n     }\n\n   Interesting events include click, mousemove, mouseup\/down. You can\n   use all jQuery events. Usually, the event handlers will update the\n   state by drawing something (add a drawOverlay hook and call\n   triggerRedrawOverlay) or firing an externally visible event for\n   user code. See the crosshair plugin for an example.\n     \n   Currently, eventHolder actually contains both the static canvas\n   used for the plot itself and the overlay canvas used for\n   interactive features because some versions of IE get the stacking\n   order wrong. The hook only gets one event, though (either for the\n   overlay or for the static canvas).\n\n   Note that custom plot events generated by Flot are not generated on\n   eventHolder, but on the div placeholder supplied as the first\n   argument to the plot call. You can get that with\n   plot.getPlaceholder() - that's probably also the one you should use\n   if you need to fire a custom event.\n\n\n - drawOverlay  [phase 7]\n\n   function (plot, canvascontext)\n\n   The drawOverlay hook is used for interactive things that need a\n   canvas to draw on. The model currently used by Flot works the way\n   that an extra overlay canvas is positioned on top of the static\n   canvas. This overlay is cleared and then completely redrawn\n   whenever something interesting happens. This hook is called when\n   the overlay canvas is to be redrawn.\n\n   \"canvascontext\" is the 2D context of the overlay canvas. You can\n   use this to draw things. You'll most likely need some of the\n   metrics computed by Flot, e.g. plot.width()\/plot.height(). See the\n   crosshair plugin for an example.\n\n\n - shutdown  [phase 8]\n\n   function (plot, eventHolder)\n\n   Run when plot.shutdown() is called, which usually only happens in\n   case a plot is overwritten by a new plot. If you're writing a\n   plugin that adds extra DOM elements or event handlers, you should\n   add a callback to clean up after you. Take a look at the section in\n   PLUGINS.txt for more info.\n\n   \nPlugins\n-------\n\nPlugins extend the functionality of Flot. To use a plugin, simply\ninclude its Javascript file after Flot in the HTML page.\n\nIf you're worried about download size\/latency, you can concatenate all\nthe plugins you use, and Flot itself for that matter, into one big file\n(make sure you get the order right), then optionally run it through a\nJavascript minifier such as YUI Compressor.\n\nHere's a brief explanation of how the plugin plumbings work:\n\nEach plugin registers itself in the global array $.plot.plugins. When\nyou make a new plot object with $.plot, Flot goes through this array\ncalling the \"init\" function of each plugin and merging default options\nfrom the \"option\" attribute of the plugin. The init function gets a\nreference to the plot object created and uses this to register hooks\nand add new public methods if needed.\n\nSee the PLUGINS.txt file for details on how to write a plugin. As the\nabove description hints, it's actually pretty easy.\n\n\nVersion number\n--------------\n\nThe version number of Flot is available in $.plot.version.\n","_u":"js\/flot\/API.txt"}