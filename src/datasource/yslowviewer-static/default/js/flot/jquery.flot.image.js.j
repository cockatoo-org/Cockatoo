{"etag":"a8ac5bc-33b-9578d6f7","type":"text\/javascript","exp":"86400","desc":null,"data":"\/*\nFlot plugin for plotting images, e.g. useful for putting ticks on a\nprerendered complex visualization.\n\nThe data syntax is [[image, x1, y1, x2, y2], ...] where (x1, y1) and\n(x2, y2) are where you intend the two opposite corners of the image to\nend up in the plot. Image must be a fully loaded Javascript image (you\ncan make one with new Image()). If the image is not complete, it's\nskipped when plotting.\n\nThere are two helpers included for retrieving images. The easiest work\nthe way that you put in URLs instead of images in the data (like\n[\"myimage.png\", 0, 0, 10, 10]), then call $.plot.image.loadData(data,\noptions, callback) where data and options are the same as you pass in\nto $.plot. This loads the images, replaces the URLs in the data with\nthe corresponding images and calls \"callback\" when all images are\nloaded (or failed loading). In the callback, you can then call $.plot\nwith the data set. See the included example.\n\nA more low-level helper, $.plot.image.load(urls, callback) is also\nincluded. Given a list of URLs, it calls callback with an object\nmapping from URL to Image object when all images are loaded or have\nfailed loading.\n\nOptions for the plugin are\n\n  series: {\n      images: {\n          show: boolean\n          anchor: \"corner\" or \"center\"\n          alpha: [0,1]\n      }\n  }\n\nwhich can be specified for a specific series\n\n  $.plot($(\"#placeholder\"), [{ data: [ ... ], images: { ... } ])\n\nNote that because the data format is different from usual data points,\nyou can't use images with anything else in a specific data series.\n\nSetting \"anchor\" to \"center\" causes the pixels in the image to be\nanchored at the corner pixel centers inside of at the pixel corners,\neffectively letting half a pixel stick out to each side in the plot.\n\n\nA possible future direction could be support for tiling for large\nimages (like Google Maps).\n\n*\/\n\n(function ($) {\n    var options = {\n        series: {\n            images: {\n                show: false,\n                alpha: 1,\n                anchor: \"corner\" \/\/ or \"center\"\n            }\n        }\n    };\n\n    $.plot.image = {};\n\n    $.plot.image.loadDataImages = function (series, options, callback) {\n        var urls = [], points = [];\n\n        var defaultShow = options.series.images.show;\n        \n        $.each(series, function (i, s) {\n            if (!(defaultShow || s.images.show))\n                return;\n            \n            if (s.data)\n                s = s.data;\n\n            $.each(s, function (i, p) {\n                if (typeof p[0] == \"string\") {\n                    urls.push(p[0]);\n                    points.push(p);\n                }\n            });\n        });\n\n        $.plot.image.load(urls, function (loadedImages) {\n            $.each(points, function (i, p) {\n                var url = p[0];\n                if (loadedImages[url])\n                    p[0] = loadedImages[url];\n            });\n\n            callback();\n        });\n    }\n    \n    $.plot.image.load = function (urls, callback) {\n        var missing = urls.length, loaded = {};\n        if (missing == 0)\n            callback({});\n\n        $.each(urls, function (i, url) {\n            var handler = function () {\n                --missing;\n                \n                loaded[url] = this;\n                \n                if (missing == 0)\n                    callback(loaded);\n            };\n\n            $('<img \/>').load(handler).error(handler).attr('src', url);\n        });\n    }\n    \n    function drawSeries(plot, ctx, series) {\n        var plotOffset = plot.getPlotOffset();\n        \n        if (!series.images || !series.images.show)\n            return;\n        \n        var points = series.datapoints.points,\n            ps = series.datapoints.pointsize;\n        \n        for (var i = 0; i < points.length; i += ps) {\n            var img = points[i],\n                x1 = points[i + 1], y1 = points[i + 2],\n                x2 = points[i + 3], y2 = points[i + 4],\n                xaxis = series.xaxis, yaxis = series.yaxis,\n                tmp;\n\n            \/\/ actually we should check img.complete, but it\n            \/\/ appears to be a somewhat unreliable indicator in\n            \/\/ IE6 (false even after load event)\n            if (!img || img.width <= 0 || img.height <= 0)\n                continue;\n\n            if (x1 > x2) {\n                tmp = x2;\n                x2 = x1;\n                x1 = tmp;\n            }\n            if (y1 > y2) {\n                tmp = y2;\n                y2 = y1;\n                y1 = tmp;\n            }\n            \n            \/\/ if the anchor is at the center of the pixel, expand the \n            \/\/ image by 1\/2 pixel in each direction\n            if (series.images.anchor == \"center\") {\n                tmp = 0.5 * (x2-x1) \/ (img.width - 1);\n                x1 -= tmp;\n                x2 += tmp;\n                tmp = 0.5 * (y2-y1) \/ (img.height - 1);\n                y1 -= tmp;\n                y2 += tmp;\n            }\n            \n            \/\/ clip\n            if (x1 == x2 || y1 == y2 ||\n                x1 >= xaxis.max || x2 <= xaxis.min ||\n                y1 >= yaxis.max || y2 <= yaxis.min)\n                continue;\n\n            var sx1 = 0, sy1 = 0, sx2 = img.width, sy2 = img.height;\n            if (x1 < xaxis.min) {\n                sx1 += (sx2 - sx1) * (xaxis.min - x1) \/ (x2 - x1);\n                x1 = xaxis.min;\n            }\n\n            if (x2 > xaxis.max) {\n                sx2 += (sx2 - sx1) * (xaxis.max - x2) \/ (x2 - x1);\n                x2 = xaxis.max;\n            }\n\n            if (y1 < yaxis.min) {\n                sy2 += (sy1 - sy2) * (yaxis.min - y1) \/ (y2 - y1);\n                y1 = yaxis.min;\n            }\n\n            if (y2 > yaxis.max) {\n                sy1 += (sy1 - sy2) * (yaxis.max - y2) \/ (y2 - y1);\n                y2 = yaxis.max;\n            }\n            \n            x1 = xaxis.p2c(x1);\n            x2 = xaxis.p2c(x2);\n            y1 = yaxis.p2c(y1);\n            y2 = yaxis.p2c(y2);\n            \n            \/\/ the transformation may have swapped us\n            if (x1 > x2) {\n                tmp = x2;\n                x2 = x1;\n                x1 = tmp;\n            }\n            if (y1 > y2) {\n                tmp = y2;\n                y2 = y1;\n                y1 = tmp;\n            }\n\n            tmp = ctx.globalAlpha;\n            ctx.globalAlpha *= series.images.alpha;\n            ctx.drawImage(img,\n                          sx1, sy1, sx2 - sx1, sy2 - sy1,\n                          x1 + plotOffset.left, y1 + plotOffset.top,\n                          x2 - x1, y2 - y1);\n            ctx.globalAlpha = tmp;\n        }\n    }\n\n    function processRawData(plot, series, data, datapoints) {\n        if (!series.images.show)\n            return;\n\n        \/\/ format is Image, x1, y1, x2, y2 (opposite corners)\n        datapoints.format = [\n            { required: true },\n            { x: true, number: true, required: true },\n            { y: true, number: true, required: true },\n            { x: true, number: true, required: true },\n            { y: true, number: true, required: true }\n        ];\n    }\n    \n    function init(plot) {\n        plot.hooks.processRawData.push(processRawData);\n        plot.hooks.drawSeries.push(drawSeries);\n    }\n    \n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'image',\n        version: '1.1'\n    });\n})(jQuery);\n","_u":"js\/flot\/jquery.flot.image.js"}