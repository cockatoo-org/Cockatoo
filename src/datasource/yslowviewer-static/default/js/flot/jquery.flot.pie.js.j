{"etag":"\"4cf6bb82-c906-4806-a252f721f439861c\"","type":"text\/javascript","exp":"86400","desc":null,"data":"\/*\r\nFlot plugin for rendering pie charts. The plugin assumes the data is \r\ncoming is as a single data value for each series, and each of those \r\nvalues is a positive value or zero (negative numbers don't make \r\nany sense and will cause strange effects). The data values do \r\nNOT need to be passed in as percentage values because it \r\ninternally calculates the total and percentages.\r\n\r\n* Created by Brian Medendorp, June 2009\r\n* Updated November 2009 with contributions from: btburnett3, Anthony Aragues and Xavi Ivars\r\n\r\n* Changes:\r\n\t2009-10-22: lineJoin set to round\r\n\t2009-10-23: IE full circle fix, donut\r\n\t2009-11-11: Added basic hover from btburnett3 - does not work in IE, and center is off in Chrome and Opera\r\n\t2009-11-17: Added IE hover capability submitted by Anthony Aragues\r\n\t2009-11-18: Added bug fix submitted by Xavi Ivars (issues with arrays when other JS libraries are included as well)\r\n\t\t\r\n\r\nAvailable options are:\r\nseries: {\r\n\tpie: {\r\n\t\tshow: true\/false\r\n\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\r\n\t\tinnerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\r\n\t\tstartAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3\/2 starts at the top, 0 and 2 have the same result\r\n\t\ttilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\r\n\t\toffset: {\r\n\t\t\ttop: integer value to move the pie up or down\r\n\t\t\tleft: integer value to move the pie left or right, or 'auto'\r\n\t\t},\r\n\t\tstroke: {\r\n\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\r\n\t\t\twidth: integer pixel width of the stroke\r\n\t\t},\r\n\t\tlabel: {\r\n\t\t\tshow: true\/false, or 'auto'\r\n\t\t\tformatter:  a user-defined function that modifies the text\/style of the label text\r\n\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length\r\n\t\t\tbackground: {\r\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\r\n\t\t\t\topacity: 0-1\r\n\t\t\t},\r\n\t\t\tthreshold: 0-1 for the percentage value at which to hide labels (if they're too small)\r\n\t\t},\r\n\t\tcombine: {\r\n\t\t\tthreshold: 0-1 for the percentage value at which to combine slices (if they're too small)\r\n\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\r\n\t\t\tlabel: any text value of what the combined slice should be labeled\r\n\t\t}\r\n\t\thighlight: {\r\n\t\t\topacity: 0-1\r\n\t\t}\r\n\t}\r\n}\r\n\r\nMore detail and specific examples can be found in the included HTML file.\r\n\r\n*\/\r\n\r\n(function ($) \r\n{\r\n\tfunction init(plot) \/\/ this is the \"body\" of the plugin\r\n\t{\r\n\t\tvar canvas = null;\r\n\t\tvar target = null;\r\n\t\tvar maxRadius = null;\r\n\t\tvar centerLeft = null;\r\n\t\tvar centerTop = null;\r\n\t\tvar total = 0;\r\n\t\tvar redraw = true;\r\n\t\tvar redrawAttempts = 10;\r\n\t\tvar shrink = 0.95;\r\n\t\tvar legendWidth = 0;\r\n\t\tvar processed = false;\r\n\t\tvar raw = false;\r\n\t\t\r\n\t\t\/\/ interactive variables\t\r\n\t\tvar highlights = [];\t\r\n\t\r\n\t\t\/\/ add hook to determine if pie plugin in enabled, and then perform necessary operations\r\n\t\tplot.hooks.processOptions.push(checkPieEnabled);\r\n\t\tplot.hooks.bindEvents.push(bindEvents);\t\r\n\r\n\t\t\/\/ check to see if the pie plugin is enabled\r\n\t\tfunction checkPieEnabled(plot, options)\r\n\t\t{\r\n\t\t\tif (options.series.pie.show)\r\n\t\t\t{\r\n\t\t\t\t\/\/disable grid\r\n\t\t\t\toptions.grid.show = false;\r\n\t\t\t\t\r\n\t\t\t\t\/\/ set labels.show\r\n\t\t\t\tif (options.series.pie.label.show=='auto')\r\n\t\t\t\t\tif (options.legend.show)\r\n\t\t\t\t\t\toptions.series.pie.label.show = false;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\toptions.series.pie.label.show = true;\r\n\t\t\t\t\r\n\t\t\t\t\/\/ set radius\r\n\t\t\t\tif (options.series.pie.radius=='auto')\r\n\t\t\t\t\tif (options.series.pie.label.show)\r\n\t\t\t\t\t\toptions.series.pie.radius = 3\/4;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\toptions.series.pie.radius = 1;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\/\/ ensure sane tilt\r\n\t\t\t\tif (options.series.pie.tilt>1)\r\n\t\t\t\t\toptions.series.pie.tilt=1;\r\n\t\t\t\tif (options.series.pie.tilt<0)\r\n\t\t\t\t\toptions.series.pie.tilt=0;\r\n\t\t\t\r\n\t\t\t\t\/\/ add processData hook to do transformations on the data\r\n\t\t\t\tplot.hooks.processDatapoints.push(processDatapoints);\r\n\t\t\t\tplot.hooks.drawOverlay.push(drawOverlay);\t\r\n\t\t\t\t\r\n\t\t\t\t\/\/ add draw hook\r\n\t\t\t\tplot.hooks.draw.push(draw);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t\/\/ bind hoverable events\r\n\t\tfunction bindEvents(plot, eventHolder) \t\t\r\n\t\t{\t\t\r\n\t\t\tvar options = plot.getOptions();\r\n\t\t\t\r\n\t\t\tif (options.series.pie.show && options.grid.hoverable)\r\n\t\t\t\teventHolder.unbind('mousemove').mousemove(onMouseMove);\r\n\t\t\t\t\r\n\t\t\tif (options.series.pie.show && options.grid.clickable)\r\n\t\t\t\teventHolder.unbind('click').click(onClick);\r\n\t\t}\t\r\n\t\t\r\n\r\n\t\t\/\/ debugging function that prints out an object\r\n\t\tfunction alertObject(obj)\r\n\t\t{\r\n\t\t\tvar msg = '';\r\n\t\t\tfunction traverse(obj, depth)\r\n\t\t\t{\r\n\t\t\t\tif (!depth)\r\n\t\t\t\t\tdepth = 0;\r\n\t\t\t\tfor (var i = 0; i < obj.length; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (var j=0; j<depth; j++)\r\n\t\t\t\t\t\tmsg += '\\t';\r\n\t\t\t\t\r\n\t\t\t\t\tif( typeof obj[i] == \"object\")\r\n\t\t\t\t\t{\t\/\/ its an object\r\n\t\t\t\t\t\tmsg += ''+i+':\\n';\r\n\t\t\t\t\t\ttraverse(obj[i], depth+1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\t\/\/ its a value\r\n\t\t\t\t\t\tmsg += ''+i+': '+obj[i]+'\\n';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttraverse(obj);\r\n\t\t\talert(msg);\r\n\t\t}\r\n\t\t\r\n\t\tfunction calcTotal(data)\r\n\t\t{\r\n\t\t\tfor (var i = 0; i < data.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar item = parseFloat(data[i].data[0][1]);\r\n\t\t\t\tif (item)\r\n\t\t\t\t\ttotal += item;\r\n\t\t\t}\r\n\t\t}\t\r\n\t\t\r\n\t\tfunction processDatapoints(plot, series, data, datapoints) \r\n\t\t{\t\r\n\t\t\tif (!processed)\r\n\t\t\t{\r\n\t\t\t\tprocessed = true;\r\n\t\t\t\r\n\t\t\t\tcanvas = plot.getCanvas();\r\n\t\t\t\ttarget = $(canvas).parent();\r\n\t\t\t\toptions = plot.getOptions();\r\n\t\t\t\r\n\t\t\t\tplot.setData(combine(plot.getData()));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfunction setupPie()\r\n\t\t{\r\n\t\t\tlegendWidth = target.children().filter('.legend').children().width();\r\n\t\t\r\n\t\t\t\/\/ calculate maximum radius and center point\r\n\t\t\tmaxRadius =  Math.min(canvas.width,(canvas.height\/options.series.pie.tilt))\/2;\r\n\t\t\tcenterTop = (canvas.height\/2)+options.series.pie.offset.top;\r\n\t\t\tcenterLeft = (canvas.width\/2);\r\n\t\t\t\r\n\t\t\tif (options.series.pie.offset.left=='auto')\r\n\t\t\t\tif (options.legend.position.match('w'))\r\n\t\t\t\t\tcenterLeft += legendWidth\/2;\r\n\t\t\t\telse\r\n\t\t\t\t\tcenterLeft -= legendWidth\/2;\r\n\t\t\telse\r\n\t\t\t\tcenterLeft += options.series.pie.offset.left;\r\n\t\t\t\t\t\r\n\t\t\tif (centerLeft<maxRadius)\r\n\t\t\t\tcenterLeft = maxRadius;\r\n\t\t\telse if (centerLeft>canvas.width-maxRadius)\r\n\t\t\t\tcenterLeft = canvas.width-maxRadius;\r\n\t\t}\r\n\t\t\r\n\t\tfunction fixData(data)\r\n\t\t{\r\n\t\t\tfor (var i = 0; i < data.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tif (typeof(data[i].data)=='number')\r\n\t\t\t\t\tdata[i].data = [[1,data[i].data]];\r\n\t\t\t\telse if (typeof(data[i].data)=='undefined' || typeof(data[i].data[0])=='undefined')\r\n\t\t\t\t{\r\n\t\t\t\t\tif (typeof(data[i].data)!='undefined' && typeof(data[i].data.label)!='undefined')\r\n\t\t\t\t\t\tdata[i].label = data[i].data.label; \/\/ fix weirdness coming from flot\r\n\t\t\t\t\tdata[i].data = [[1,0]];\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\t\t\r\n\t\tfunction combine(data)\r\n\t\t{\r\n\t\t\tdata = fixData(data);\r\n\t\t\tcalcTotal(data);\r\n\t\t\tvar combined = 0;\r\n\t\t\tvar numCombined = 0;\r\n\t\t\tvar color = options.series.pie.combine.color;\r\n\t\t\t\r\n\t\t\tvar newdata = [];\r\n\t\t\tfor (var i = 0; i < data.length; ++i)\r\n\t\t\t{\r\n\t\t\t\t\/\/ make sure its a number\r\n\t\t\t\tdata[i].data[0][1] = parseFloat(data[i].data[0][1]);\r\n\t\t\t\tif (!data[i].data[0][1])\r\n\t\t\t\t\tdata[i].data[0][1] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\tif (data[i].data[0][1]\/total<=options.series.pie.combine.threshold)\r\n\t\t\t\t{\r\n\t\t\t\t\tcombined += data[i].data[0][1];\r\n\t\t\t\t\tnumCombined++;\r\n\t\t\t\t\tif (!color)\r\n\t\t\t\t\t\tcolor = data[i].color;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tnewdata.push({\r\n\t\t\t\t\t\tdata: [[1,data[i].data[0][1]]], \r\n\t\t\t\t\t\tcolor: data[i].color, \r\n\t\t\t\t\t\tlabel: data[i].label,\r\n\t\t\t\t\t\tangle: (data[i].data[0][1]*(Math.PI*2))\/total,\r\n\t\t\t\t\t\tpercent: (data[i].data[0][1]\/total*100)\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (numCombined>0)\r\n\t\t\t\tnewdata.push({\r\n\t\t\t\t\tdata: [[1,combined]], \r\n\t\t\t\t\tcolor: color, \r\n\t\t\t\t\tlabel: options.series.pie.combine.label,\r\n\t\t\t\t\tangle: (combined*(Math.PI*2))\/total,\r\n\t\t\t\t\tpercent: (combined\/total*100)\r\n\t\t\t\t});\r\n\t\t\treturn newdata;\r\n\t\t}\t\t\r\n\t\t\r\n\t\tfunction draw(plot, newCtx)\r\n\t\t{\r\n\t\t\tif (!target) return; \/\/ if no series were passed\r\n\t\t\tctx = newCtx;\r\n\t\t\r\n\t\t\tsetupPie();\r\n\t\t\tvar slices = plot.getData();\r\n\t\t\r\n\t\t\tvar attempts = 0;\r\n\t\t\twhile (redraw && attempts<redrawAttempts)\r\n\t\t\t{\r\n\t\t\t\tredraw = false;\r\n\t\t\t\tif (attempts>0)\r\n\t\t\t\t\tmaxRadius *= shrink;\r\n\t\t\t\tattempts += 1;\r\n\t\t\t\tclear();\r\n\t\t\t\tif (options.series.pie.tilt<=0.8)\r\n\t\t\t\t\tdrawShadow();\r\n\t\t\t\tdrawPie();\r\n\t\t\t}\r\n\t\t\tif (attempts >= redrawAttempts) {\r\n\t\t\t\tclear();\r\n\t\t\t\ttarget.prepend('<div class=\"error\">Could not draw pie with labels contained inside canvas<\/div>');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( plot.setSeries && plot.insertLegend )\r\n\t\t\t{\r\n\t\t\t\tplot.setSeries(slices);\r\n\t\t\t\tplot.insertLegend();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\/\/ we're actually done at this point, just defining internal functions at this point\r\n\t\t\t\r\n\t\t\tfunction clear()\r\n\t\t\t{\r\n\t\t\t\tctx.clearRect(0,0,canvas.width,canvas.height);\r\n\t\t\t\ttarget.children().filter('.pieLabel, .pieLabelBackground').remove();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction drawShadow()\r\n\t\t\t{\r\n\t\t\t\tvar shadowLeft = 5;\r\n\t\t\t\tvar shadowTop = 15;\r\n\t\t\t\tvar edge = 10;\r\n\t\t\t\tvar alpha = 0.02;\r\n\t\t\t\r\n\t\t\t\t\/\/ set radius\r\n\t\t\t\tif (options.series.pie.radius>1)\r\n\t\t\t\t\tvar radius = options.series.pie.radius;\r\n\t\t\t\telse\r\n\t\t\t\t\tvar radius = maxRadius * options.series.pie.radius;\r\n\t\t\t\t\t\r\n\t\t\t\tif (radius>=(canvas.width\/2)-shadowLeft || radius*options.series.pie.tilt>=(canvas.height\/2)-shadowTop || radius<=edge)\r\n\t\t\t\t\treturn;\t\/\/ shadow would be outside canvas, so don't draw it\r\n\t\t\t\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.translate(shadowLeft,shadowTop);\r\n\t\t\t\tctx.globalAlpha = alpha;\r\n\t\t\t\tctx.fillStyle = '#000';\r\n\r\n\t\t\t\t\/\/ center and rotate to starting position\r\n\t\t\t\tctx.translate(centerLeft,centerTop);\r\n\t\t\t\tctx.scale(1, options.series.pie.tilt);\r\n\t\t\t\t\r\n\t\t\t\t\/\/radius -= edge;\r\n\t\t\t\tfor (var i=1; i<=edge; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.arc(0,0,radius,0,Math.PI*2,false);\r\n\t\t\t\t\tctx.fill();\r\n\t\t\t\t\tradius -= i;\r\n\t\t\t\t}\t\r\n\t\t\t\t\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction drawPie()\r\n\t\t\t{\r\n\t\t\t\tstartAngle = Math.PI*options.series.pie.startAngle;\r\n\t\t\t\t\r\n\t\t\t\t\/\/ set radius\r\n\t\t\t\tif (options.series.pie.radius>1)\r\n\t\t\t\t\tvar radius = options.series.pie.radius;\r\n\t\t\t\telse\r\n\t\t\t\t\tvar radius = maxRadius * options.series.pie.radius;\r\n\t\t\t\t\r\n\t\t\t\t\/\/ center and rotate to starting position\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.translate(centerLeft,centerTop);\r\n\t\t\t\tctx.scale(1, options.series.pie.tilt);\r\n\t\t\t\t\/\/ctx.rotate(startAngle); \/\/ start at top; -- This doesn't work properly in Opera\r\n\t\t\t\t\r\n\t\t\t\t\/\/ draw slices\r\n\t\t\t\tctx.save();\r\n\t\t\t\tvar currentAngle = startAngle;\r\n\t\t\t\tfor (var i = 0; i < slices.length; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tslices[i].startAngle = currentAngle;\r\n\t\t\t\t\tdrawSlice(slices[i].angle, slices[i].color, true);\r\n\t\t\t\t}\r\n\t\t\t\tctx.restore();\r\n\t\t\t\t\r\n\t\t\t\t\/\/ draw slice outlines\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.lineWidth = options.series.pie.stroke.width;\r\n\t\t\t\tcurrentAngle = startAngle;\r\n\t\t\t\tfor (var i = 0; i < slices.length; ++i)\r\n\t\t\t\t\tdrawSlice(slices[i].angle, options.series.pie.stroke.color, false);\r\n\t\t\t\tctx.restore();\r\n\t\t\t\t\t\r\n\t\t\t\t\/\/ draw donut hole\r\n\t\t\t\tdrawDonutHole(ctx);\r\n\t\t\t\t\r\n\t\t\t\t\/\/ draw labels\r\n\t\t\t\tif (options.series.pie.label.show)\r\n\t\t\t\t\tdrawLabels();\r\n\t\t\t\t\r\n\t\t\t\t\/\/ restore to original state\r\n\t\t\t\tctx.restore();\r\n\t\t\t\t\r\n\t\t\t\tfunction drawSlice(angle, color, fill)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tif (angle<=0)\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t\t\tif (fill)\r\n\t\t\t\t\t\tctx.fillStyle = color;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tctx.strokeStyle = color;\r\n\t\t\t\t\t\tctx.lineJoin = 'round';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tif (Math.abs(angle - Math.PI*2) > 0.000000001)\r\n\t\t\t\t\t\tctx.moveTo(0,0); \/\/ Center of the pie\r\n\t\t\t\t\telse if ($.browser.msie)\r\n\t\t\t\t\t\tangle -= 0.0001;\r\n\t\t\t\t\t\/\/ctx.arc(0,0,radius,0,angle,false); \/\/ This doesn't work properly in Opera\r\n\t\t\t\t\tctx.arc(0,0,radius,currentAngle,currentAngle+angle,false);\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t\t\/\/ctx.rotate(angle); \/\/ This doesn't work properly in Opera\r\n\t\t\t\t\tcurrentAngle += angle;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (fill)\r\n\t\t\t\t\t\tctx.fill();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tctx.stroke();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction drawLabels()\r\n\t\t\t\t{\r\n\t\t\t\t\tvar currentAngle = startAngle;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\/\/ set radius\r\n\t\t\t\t\tif (options.series.pie.label.radius>1)\r\n\t\t\t\t\t\tvar radius = options.series.pie.label.radius;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tvar radius = maxRadius * options.series.pie.label.radius;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (var i = 0; i < slices.length; ++i)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (slices[i].percent >= options.series.pie.label.threshold*100)\r\n\t\t\t\t\t\t\tdrawLabel(slices[i], currentAngle, i);\r\n\t\t\t\t\t\tcurrentAngle += slices[i].angle;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfunction drawLabel(slice, startAngle, index)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (slice.data[0][1]==0)\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\/\/ format label text\r\n\t\t\t\t\t\tvar lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;\r\n\t\t\t\t\t\tif (lf)\r\n\t\t\t\t\t\t\ttext = lf(slice.label, slice);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\ttext = slice.label;\r\n\t\t\t\t\t\tif (plf)\r\n\t\t\t\t\t\t\ttext = plf(text, slice);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar halfAngle = ((startAngle+slice.angle) + startAngle)\/2;\r\n\t\t\t\t\t\tvar x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\r\n\t\t\t\t\t\tvar y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar html = '<span class=\"pieLabel\" id=\"pieLabel'+index+'\" style=\"position:absolute;top:' + y + 'px;left:' + x + 'px;\">' + text + \"<\/span>\";\r\n\t\t\t\t\t\ttarget.append(html);\r\n\t\t\t\t\t\tvar label = target.children('#pieLabel'+index);\r\n\t\t\t\t\t\tvar labelTop = (y - label.height()\/2);\r\n\t\t\t\t\t\tvar labelLeft = (x - label.width()\/2);\r\n\t\t\t\t\t\tlabel.css('top', labelTop);\r\n\t\t\t\t\t\tlabel.css('left', labelLeft);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\/\/ check to make sure that the label is not outside the canvas\r\n\t\t\t\t\t\tif (0-labelTop>0 || 0-labelLeft>0 || canvas.height-(labelTop+label.height())<0 || canvas.width-(labelLeft+label.width())<0)\r\n\t\t\t\t\t\t\tredraw = true;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (options.series.pie.label.background.opacity != 0) {\r\n\t\t\t\t\t\t\t\/\/ put in the transparent background separately to avoid blended labels and label boxes\r\n\t\t\t\t\t\t\tvar c = options.series.pie.label.background.color;\r\n\t\t\t\t\t\t\tif (c == null) {\r\n\t\t\t\t\t\t\t\tc = slice.color;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar pos = 'top:'+labelTop+'px;left:'+labelLeft+'px;';\r\n\t\t\t\t\t\t\t$('<div class=\"pieLabelBackground\" style=\"position:absolute;width:' + label.width() + 'px;height:' + label.height() + 'px;' + pos +'background-color:' + c + ';\"> <\/div>').insertBefore(label).css('opacity', options.series.pie.label.background.opacity);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} \/\/ end individual label function\r\n\t\t\t\t} \/\/ end drawLabels function\r\n\t\t\t} \/\/ end drawPie function\r\n\t\t} \/\/ end draw function\r\n\t\t\r\n\t\t\/\/ Placed here because it needs to be accessed from multiple locations \r\n\t\tfunction drawDonutHole(layer)\r\n\t\t{\r\n\t\t\t\/\/ draw donut hole\r\n\t\t\tif(options.series.pie.innerRadius > 0)\r\n\t\t\t{\r\n\t\t\t\t\/\/ subtract the center\r\n\t\t\t\tlayer.save();\r\n\t\t\t\tinnerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\r\n\t\t\t\tlayer.globalCompositeOperation = 'destination-out'; \/\/ this does not work with excanvas, but it will fall back to using the stroke color\r\n\t\t\t\tlayer.beginPath();\r\n\t\t\t\tlayer.fillStyle = options.series.pie.stroke.color;\r\n\t\t\t\tlayer.arc(0,0,innerRadius,0,Math.PI*2,false);\r\n\t\t\t\tlayer.fill();\r\n\t\t\t\tlayer.closePath();\r\n\t\t\t\tlayer.restore();\r\n\t\t\t\t\r\n\t\t\t\t\/\/ add inner stroke\r\n\t\t\t\tlayer.save();\r\n\t\t\t\tlayer.beginPath();\r\n\t\t\t\tlayer.strokeStyle = options.series.pie.stroke.color;\r\n\t\t\t\tlayer.arc(0,0,innerRadius,0,Math.PI*2,false);\r\n\t\t\t\tlayer.stroke();\r\n\t\t\t\tlayer.closePath();\r\n\t\t\t\tlayer.restore();\r\n\t\t\t\t\/\/ TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\/\/-- Additional Interactive related functions --\r\n\t\t\r\n\t\tfunction isPointInPoly(poly, pt)\r\n\t\t{\r\n\t\t\tfor(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\r\n\t\t\t\t((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1]< poly[i][1]))\r\n\t\t\t\t&& (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) \/ (poly[j][1] - poly[i][1]) + poly[i][0])\r\n\t\t\t\t&& (c = !c);\r\n\t\t\treturn c;\r\n\t\t}\r\n\t\t\r\n\t\tfunction findNearbySlice(mouseX, mouseY)\r\n\t\t{\r\n\t\t\tvar slices = plot.getData(),\r\n\t\t\t\toptions = plot.getOptions(),\r\n\t\t\t\tradius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < slices.length; ++i) \r\n\t\t\t{\r\n\t\t\t\tvar s = slices[i];\t\r\n\t\t\t\t\r\n\t\t\t\tif(s.pie.show)\r\n\t\t\t\t{\r\n\t\t\t\t\tctx.save();\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(0,0); \/\/ Center of the pie\r\n\t\t\t\t\t\/\/ctx.scale(1, options.series.pie.tilt);\t\/\/ this actually seems to break everything when here.\r\n\t\t\t\t\tctx.arc(0,0,radius,s.startAngle,s.startAngle+s.angle,false);\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t\tx = mouseX-centerLeft;\r\n\t\t\t\t\ty = mouseY-centerTop;\r\n\t\t\t\t\tif(ctx.isPointInPath)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (ctx.isPointInPath(mouseX-centerLeft, mouseY-centerTop))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\/\/alert('found slice!');\r\n\t\t\t\t\t\t\tctx.restore();\r\n\t\t\t\t\t\t\treturn {datapoint: [s.percent, s.data], dataIndex: 0, series: s, seriesIndex: i};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\/\/ excanvas for IE doesn;t support isPointInPath, this is a workaround. \r\n\t\t\t\t\t\tp1X = (radius * Math.cos(s.startAngle));\r\n\t\t\t\t\t\tp1Y = (radius * Math.sin(s.startAngle));\r\n\t\t\t\t\t\tp2X = (radius * Math.cos(s.startAngle+(s.angle\/4)));\r\n\t\t\t\t\t\tp2Y = (radius * Math.sin(s.startAngle+(s.angle\/4)));\r\n\t\t\t\t\t\tp3X = (radius * Math.cos(s.startAngle+(s.angle\/2)));\r\n\t\t\t\t\t\tp3Y = (radius * Math.sin(s.startAngle+(s.angle\/2)));\r\n\t\t\t\t\t\tp4X = (radius * Math.cos(s.startAngle+(s.angle\/1.5)));\r\n\t\t\t\t\t\tp4Y = (radius * Math.sin(s.startAngle+(s.angle\/1.5)));\r\n\t\t\t\t\t\tp5X = (radius * Math.cos(s.startAngle+s.angle));\r\n\t\t\t\t\t\tp5Y = (radius * Math.sin(s.startAngle+s.angle));\r\n\t\t\t\t\t\tarrPoly = [[0,0],[p1X,p1Y],[p2X,p2Y],[p3X,p3Y],[p4X,p4Y],[p5X,p5Y]];\r\n\t\t\t\t\t\tarrPoint = [x,y];\r\n\t\t\t\t\t\t\/\/ TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\r\n\t\t\t\t\t\tif(isPointInPoly(arrPoly, arrPoint))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tctx.restore();\r\n\t\t\t\t\t\t\treturn {datapoint: [s.percent, s.data], dataIndex: 0, series: s, seriesIndex: i};\r\n\t\t\t\t\t\t}\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.restore();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tfunction onMouseMove(e) \r\n\t\t{\r\n\t\t\ttriggerClickHoverEvent('plothover', e);\r\n\t\t}\r\n\t\t\r\n        function onClick(e) \r\n\t\t{\r\n\t\t\ttriggerClickHoverEvent('plotclick', e);\r\n        }\r\n\r\n\t\t\/\/ trigger click or hover event (they send the same parameters so we share their code)\r\n\t\tfunction triggerClickHoverEvent(eventname, e) \r\n\t\t{\r\n\t\t\tvar offset = plot.offset(),\r\n\t\t\t\tcanvasX = parseInt(e.pageX - offset.left),\r\n\t\t\t\tcanvasY =  parseInt(e.pageY - offset.top),\r\n\t\t\t\titem = findNearbySlice(canvasX, canvasY);\r\n\t\t\t\r\n\t\t\tif (options.grid.autoHighlight) \r\n\t\t\t{\r\n\t\t\t\t\/\/ clear auto-highlights\r\n\t\t\t\tfor (var i = 0; i < highlights.length; ++i) \r\n\t\t\t\t{\r\n\t\t\t\t\tvar h = highlights[i];\r\n\t\t\t\t\tif (h.auto == eventname && !(item && h.series == item.series))\r\n\t\t\t\t\t\tunhighlight(h.series);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\/\/ highlight the slice\r\n\t\t\tif (item) \r\n\t\t\t    highlight(item.series, eventname);\r\n\t\t\t\t\r\n\t\t\t\/\/ trigger any hover bind events\r\n\t\t\tvar pos = { pageX: e.pageX, pageY: e.pageY };\r\n\t\t\ttarget.trigger(eventname, [ pos, item ]);\t\r\n\t\t}\r\n\r\n\t\tfunction highlight(s, auto) \r\n\t\t{\r\n\t\t\tif (typeof s == \"number\")\r\n\t\t\t\ts = series[s];\r\n\r\n\t\t\tvar i = indexOfHighlight(s);\r\n\t\t\tif (i == -1) \r\n\t\t\t{\r\n\t\t\t\thighlights.push({ series: s, auto: auto });\r\n\t\t\t\tplot.triggerRedrawOverlay();\r\n\t\t\t}\r\n\t\t\telse if (!auto)\r\n\t\t\t\thighlights[i].auto = false;\r\n\t\t}\r\n\r\n\t\tfunction unhighlight(s) \r\n\t\t{\r\n\t\t\tif (s == null) \r\n\t\t\t{\r\n\t\t\t\thighlights = [];\r\n\t\t\t\tplot.triggerRedrawOverlay();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof s == \"number\")\r\n\t\t\t\ts = series[s];\r\n\r\n\t\t\tvar i = indexOfHighlight(s);\r\n\t\t\tif (i != -1) \r\n\t\t\t{\r\n\t\t\t\thighlights.splice(i, 1);\r\n\t\t\t\tplot.triggerRedrawOverlay();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction indexOfHighlight(s) \r\n\t\t{\r\n\t\t\tfor (var i = 0; i < highlights.length; ++i) \r\n\t\t\t{\r\n\t\t\t\tvar h = highlights[i];\r\n\t\t\t\tif (h.series == s)\r\n\t\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tfunction drawOverlay(plot, octx) \r\n\t\t{\r\n\t\t\t\/\/alert(options.series.pie.radius);\r\n\t\t\tvar options = plot.getOptions();\r\n\t\t\t\/\/alert(options.series.pie.radius);\r\n\t\t\t\r\n\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\r\n\r\n\t\t\toctx.save();\r\n\t\t\toctx.translate(centerLeft, centerTop);\r\n\t\t\toctx.scale(1, options.series.pie.tilt);\r\n\t\t\t\r\n\t\t\tfor (i = 0; i < highlights.length; ++i) \r\n\t\t\t\tdrawHighlight(highlights[i].series);\r\n\t\t\t\r\n\t\t\tdrawDonutHole(octx);\r\n\r\n\t\t\toctx.restore();\r\n\r\n\t\t\tfunction drawHighlight(series) \r\n\t\t\t{\r\n\t\t\t\tif (series.angle < 0) return;\r\n\t\t\t\t\r\n\t\t\t\t\/\/octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\r\n\t\t\t\toctx.fillStyle = \"rgba(255, 255, 255, \"+options.series.pie.highlight.opacity+\")\"; \/\/ this is temporary until we have access to parseColor\r\n\t\t\t\t\r\n\t\t\t\toctx.beginPath();\r\n\t\t\t\tif (Math.abs(series.angle - Math.PI*2) > 0.000000001)\r\n\t\t\t\t\toctx.moveTo(0,0); \/\/ Center of the pie\r\n\t\t\t\toctx.arc(0,0,radius,series.startAngle,series.startAngle+series.angle,false);\r\n\t\t\t\toctx.closePath();\r\n\t\t\t\toctx.fill();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\t\r\n\t\t\r\n\t} \/\/ end init (plugin body)\r\n\t\r\n\t\/\/ define pie specific options and their default values\r\n\tvar options = {\r\n\t\tseries: {\r\n\t\t\tpie: {\r\n\t\t\t\tshow: false,\r\n\t\t\t\tradius: 'auto',\t\/\/ actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\r\n\t\t\t\tinnerRadius:0, \/* for donut *\/\r\n\t\t\t\tstartAngle: 3\/2,\r\n\t\t\t\ttilt: 1,\r\n\t\t\t\toffset: {\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\tleft: 'auto'\r\n\t\t\t\t},\r\n\t\t\t\tstroke: {\r\n\t\t\t\t\tcolor: '#FFF',\r\n\t\t\t\t\twidth: 1\r\n\t\t\t\t},\r\n\t\t\t\tlabel: {\r\n\t\t\t\t\tshow: 'auto',\r\n\t\t\t\t\tformatter: function(label, slice){\r\n\t\t\t\t\t\treturn '<div style=\"font-size:x-small;text-align:center;padding:2px;color:'+slice.color+';\">'+label+'<br\/>'+Math.round(slice.percent)+'%<\/div>';\r\n\t\t\t\t\t},\t\/\/ formatter function\r\n\t\t\t\t\tradius: 1,\t\/\/ radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\r\n\t\t\t\t\tbackground: {\r\n\t\t\t\t\t\tcolor: null,\r\n\t\t\t\t\t\topacity: 0\r\n\t\t\t\t\t},\r\n\t\t\t\t\tthreshold: 0\t\/\/ percentage at which to hide the label (i.e. the slice is too narrow)\r\n\t\t\t\t},\r\n\t\t\t\tcombine: {\r\n\t\t\t\t\tthreshold: -1,\t\/\/ percentage at which to combine little slices into one larger slice\r\n\t\t\t\t\tcolor: null,\t\/\/ color to give the new slice (auto-generated if null)\r\n\t\t\t\t\tlabel: 'Other'\t\/\/ label to give the new slice\r\n\t\t\t\t},\r\n\t\t\t\thighlight: {\r\n\t\t\t\t\t\/\/color: '#FFF',\t\t\/\/ will add this functionality once parseColor is available\r\n\t\t\t\t\topacity: 0.5\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n    \r\n\t$.plot.plugins.push({\r\n\t\tinit: init,\r\n\t\toptions: options,\r\n\t\tname: \"pie\",\r\n\t\tversion: \"1.0\"\r\n\t});\r\n})(jQuery);\r\n","_u":"js\/flot\/jquery.flot.pie.js"}