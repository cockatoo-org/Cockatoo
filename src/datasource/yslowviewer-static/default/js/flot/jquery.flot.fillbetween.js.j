{"etag":"\"62001e80-3c55-5715-94a327da3781fbe7\"","type":"text\/javascript","exp":"86400","desc":null,"data":"\/*\nFlot plugin for computing bottoms for filled line and bar charts.\n\nThe case: you've got two series that you want to fill the area\nbetween. In Flot terms, you need to use one as the fill bottom of the\nother. You can specify the bottom of each data point as the third\ncoordinate manually, or you can use this plugin to compute it for you.\n\nIn order to name the other series, you need to give it an id, like this\n\n  var dataset = [\n       { data: [ ... ], id: \"foo\" } ,         \/\/ use default bottom\n       { data: [ ... ], fillBetween: \"foo\" }, \/\/ use first dataset as bottom\n       ];\n\n  $.plot($(\"#placeholder\"), dataset, { line: { show: true, fill: true }});\n\nAs a convenience, if the id given is a number that doesn't appear as\nan id in the series, it is interpreted as the index in the array\ninstead (so fillBetween: 0 can also mean the first series).\n  \nInternally, the plugin modifies the datapoints in each series. For\nline series, extra data points might be inserted through\ninterpolation. Note that at points where the bottom line is not\ndefined (due to a null point or start\/end of line), the current line\nwill show a gap too. The algorithm comes from the jquery.flot.stack.js\nplugin, possibly some code could be shared.\n*\/\n\n(function ($) {\n    var options = {\n        series: { fillBetween: null } \/\/ or number\n    };\n    \n    function init(plot) {\n        function findBottomSeries(s, allseries) {\n            var i;\n            for (i = 0; i < allseries.length; ++i) {\n                if (allseries[i].id == s.fillBetween)\n                    return allseries[i];\n            }\n\n            if (typeof s.fillBetween == \"number\") {\n                i = s.fillBetween;\n            \n                if (i < 0 || i >= allseries.length)\n                    return null;\n\n                return allseries[i];\n            }\n            \n            return null;\n        }\n        \n        function computeFillBottoms(plot, s, datapoints) {\n            if (s.fillBetween == null)\n                return;\n\n            var other = findBottomSeries(s, plot.getData());\n            if (!other)\n                return;\n\n            var ps = datapoints.pointsize,\n                points = datapoints.points,\n                otherps = other.datapoints.pointsize,\n                otherpoints = other.datapoints.points,\n                newpoints = [],\n                px, py, intery, qx, qy, bottom,\n                withlines = s.lines.show,\n                withbottom = ps > 2 && datapoints.format[2].y,\n                withsteps = withlines && s.lines.steps,\n                fromgap = true,\n                i = 0, j = 0, l;\n\n            while (true) {\n                if (i >= points.length)\n                    break;\n\n                l = newpoints.length;\n\n                if (points[i] == null) {\n                    \/\/ copy gaps\n                    for (m = 0; m < ps; ++m)\n                        newpoints.push(points[i + m]);\n                    i += ps;\n                }\n                else if (j >= otherpoints.length) {\n                    \/\/ for lines, we can't use the rest of the points\n                    if (!withlines) {\n                        for (m = 0; m < ps; ++m)\n                            newpoints.push(points[i + m]);\n                    }\n                    i += ps;\n                }\n                else if (otherpoints[j] == null) {\n                    \/\/ oops, got a gap\n                    for (m = 0; m < ps; ++m)\n                        newpoints.push(null);\n                    fromgap = true;\n                    j += otherps;\n                }\n                else {\n                    \/\/ cases where we actually got two points\n                    px = points[i];\n                    py = points[i + 1];\n                    qx = otherpoints[j];\n                    qy = otherpoints[j + 1];\n                    bottom = 0;\n\n                    if (px == qx) {\n                        for (m = 0; m < ps; ++m)\n                            newpoints.push(points[i + m]);\n\n                        \/\/newpoints[l + 1] += qy;\n                        bottom = qy;\n                        \n                        i += ps;\n                        j += otherps;\n                    }\n                    else if (px > qx) {\n                        \/\/ we got past point below, might need to\n                        \/\/ insert interpolated extra point\n                        if (withlines && i > 0 && points[i - ps] != null) {\n                            intery = py + (points[i - ps + 1] - py) * (qx - px) \/ (points[i - ps] - px);\n                            newpoints.push(qx);\n                            newpoints.push(intery)\n                            for (m = 2; m < ps; ++m)\n                                newpoints.push(points[i + m]);\n                            bottom = qy; \n                        }\n\n                        j += otherps;\n                    }\n                    else { \/\/ px < qx\n                        if (fromgap && withlines) {\n                            \/\/ if we come from a gap, we just skip this point\n                            i += ps;\n                            continue;\n                        }\n                            \n                        for (m = 0; m < ps; ++m)\n                            newpoints.push(points[i + m]);\n                        \n                        \/\/ we might be able to interpolate a point below,\n                        \/\/ this can give us a better y\n                        if (withlines && j > 0 && otherpoints[j - otherps] != null)\n                            bottom = qy + (otherpoints[j - otherps + 1] - qy) * (px - qx) \/ (otherpoints[j - otherps] - qx);\n\n                        \/\/newpoints[l + 1] += bottom;\n                        \n                        i += ps;\n                    }\n\n                    fromgap = false;\n                    \n                    if (l != newpoints.length && withbottom)\n                        newpoints[l + 2] = bottom;\n                }\n\n                \/\/ maintain the line steps invariant\n                if (withsteps && l != newpoints.length && l > 0\n                    && newpoints[l] != null\n                    && newpoints[l] != newpoints[l - ps]\n                    && newpoints[l + 1] != newpoints[l - ps + 1]) {\n                    for (m = 0; m < ps; ++m)\n                        newpoints[l + ps + m] = newpoints[l + m];\n                    newpoints[l + 1] = newpoints[l - ps + 1];\n                }\n            }\n\n            datapoints.points = newpoints;\n        }\n        \n        plot.hooks.processDatapoints.push(computeFillBottoms);\n    }\n    \n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'fillbetween',\n        version: '1.0'\n    });\n})(jQuery);\n","_u":"js\/flot\/jquery.flot.fillbetween.js"}