{"etag":"\"3fc87ad1-617a-f87b-8c265ef04fa25295\"","type":"text\/plain","exp":"86400","desc":null,"data":"Writing plugins\n---------------\n\nAll you need to do to make a new plugin is creating an init function\nand a set of options (if needed), stuffing it into an object and\nputting it in the $.plot.plugins array. For example:\n\n  function myCoolPluginInit(plot) {\n    plot.coolstring = \"Hello!\";\n  };\n\n  $.plot.plugins.push({ init: myCoolPluginInit, options: { ... } });\n\n  \/\/ if $.plot is called, it will return a plot object with the\n  \/\/ attribute \"coolstring\"\n\nNow, given that the plugin might run in many different places, it's\na good idea to avoid leaking names. The usual trick here is wrap the\nabove lines in an anonymous function which is called immediately, like\nthis: (function () { inner code ... })(). To make it even more robust\nin case $ is not bound to jQuery but some other Javascript library, we\ncan write it as\n\n  (function ($) {\n    \/\/ plugin definition\n    \/\/ ...\n  })(jQuery);\n\nThere's a complete example below, but you should also check out the\nplugins bundled with Flot.\n\n\nComplete example\n----------------\n  \nHere is a simple debug plugin which alerts each of the series in the\nplot. It has a single option that control whether it is enabled and\nhow much info to output:\n\n  (function ($) {\n    function init(plot) {\n      var debugLevel = 1;\n    \n      function checkDebugEnabled(plot, options) {\n        if (options.debug) {\n          debugLevel = options.debug;\n            \n          plot.hooks.processDatapoints.push(alertSeries);\n        }\n      }\n\n      function alertSeries(plot, series, datapoints) {\n        var msg = \"series \" + series.label;\n        if (debugLevel > 1)\n          msg += \" with \" + series.data.length + \" points\";\n        alert(msg);\n      }\n    \n      plot.hooks.processOptions.push(checkDebugEnabled);\n    }\n\n    var options = { debug: 0 };\n    \n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: \"simpledebug\",\n        version: \"0.1\"\n    });\n  })(jQuery);\n\nWe also define \"name\" and \"version\". It's not used by Flot, but might\nbe helpful for other plugins in resolving dependencies.\n  \nPut the above in a file named \"jquery.flot.debug.js\", include it in an\nHTML page and then it can be used with:\n\n  $.plot($(\"#placeholder\"), [...], { debug: 2 });\n\nThis simple plugin illustrates a couple of points:\n\n - It uses the anonymous function trick to avoid name pollution.\n - It can be enabled\/disabled through an option.\n - Variables in the init function can be used to store plot-specific\n   state between the hooks.\n\nThe two last points are important because there may be multiple plots\non the same page, and you'd want to make sure they are not mixed up.\n\n\nShutting down a plugin\n----------------------\n\nEach plot object has a shutdown hook which is run when plot.shutdown()\nis called. This usually mostly happens in case another plot is made on\ntop of an existing one.\n\nThe purpose of the hook is to give you a chance to unbind any event\nhandlers you've registered and remove any extra DOM things you've\ninserted.\n\nThe problem with event handlers is that you can have registered a\nhandler which is run in some point in the future, e.g. with\nsetTimeout(). Meanwhile, the plot may have been shutdown and removed,\nbut because your event handler is still referencing it, it can't be\ngarbage collected yet, and worse, if your handler eventually runs, it\nmay overwrite stuff on a completely different plot.\n\n \nSome hints on the options\n-------------------------\n   \nPlugins should always support appropriate options to enable\/disable\nthem because the plugin user may have several plots on the same page\nwhere only one should use the plugin. In most cases it's probably a\ngood idea if the plugin is turned off rather than on per default, just\nlike most of the powerful features in Flot.\n\nIf the plugin needs options that are specific to each series, like the\npoints or lines options in core Flot, you can put them in \"series\" in\nthe options object, e.g.\n\n  var options = {\n    series: {\n      downsample: {\n        algorithm: null,\n        maxpoints: 1000\n      }\n    }\n  }\n\nThen they will be copied by Flot into each series, providing default\nvalues in case none are specified.\n\nThink hard and long about naming the options. These names are going to\nbe public API, and code is going to depend on them if the plugin is\nsuccessful.\n","_u":"js\/flot\/PLUGINS.txt"}